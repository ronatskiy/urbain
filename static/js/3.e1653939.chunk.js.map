{"version":3,"sources":["core/Module.js","core/Propagator/Abstract.js","modules/PatchedConics/PropagatorPatchedConics.js","modules/PatchedConics/ModulePatchedConics.js"],"names":["Module","Object","D_Projects_github_com_urbain_ru_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","this","_classes","alias","className","undefined","Error","PropagatorAbstract","trajectory","epochFrom","stopCondition","PropagatorPatchedConics","_this","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","soiSafetyCoefficient","maxPatchError","TrajectoryDynamic","clearAfterEpoch","burns","flightEvents","filter","event","FlightEventImpulsiveBurn","epoch","curBurn","nextBurnTime","length","lastComponent","getComponentByEpoch","Math","max","nextComponentData","maxEpoch","_findNextTrajectory","addComponent","addFlightEvent","FlightEventSOIDeparture","oldSoi","newSoi","FlightEventSOIArrival","_createAfterBurnTrajectory","vector","epochTo","soi","sim","starSystem","getObject","referenceFrame","originId","ownSoiCrossing","type","EphemerisObject","TYPE_STAR","_findOwnSoiCrossing","childSoiCrossing","_findChildSoiCrossing","period","nextSoiCrossing","_createNextSoiTrajectory","parent","ko","keplerianObject","sphereCrossing","getSphereCrossingTrueAnomaly","data","patchedConics","soiRadius","getEpochByTrueAnomaly","parentSoi","_this2","crossings","isHyperbolic","maxDistance","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","childSois","Symbol","iterator","next","done","value","distance","getKeplerianObjectByEpoch","getApoapsisRadius","err","return","ta","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_loop","childKo","intervals1","_getPotentialApproachIntervals","intervals2","potentialApproachIntervals","getEpochIntervalsIntersection","sort","i1","i2","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","interval","step","isElliptic","min","t1","t2","t","prevDR","found","getR","states","position","sub_","_position","mag","getDR","r","_velocity","projectionOn","dot","getStates","getStateInOwnFrameByEpoch","getStateByEpoch","dR","t0","dR0","dR1","dR2","abs","push","d","d1","d2","_iterator2","closestCrossing","_i","crossing","keplerianObjectBase","keplerianObjectActive","radialTa","_getRadialTaBounds","taIntervals","verticalTa","_getVerticalTaBounds","getAngleIntervalsIntersection","inEpoch","outEpoch","adding","floor","maxProcessedEpoch","epochIntervals","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","taInterval","baseNormal","getNormalVector","activeNormal","equinoxVector","getPeriapsisVector","raanVector","cross","periapsisVector","inc","angle","raan","PI","TWO_PI","aop","KeplerianObject","ecc","sma","m0","mu","getPlaneCrossingTrueAnomaly","r1","getPeriapsisRadius","r2","radialTa1","radialTa2","Infinity","originalTrajectory","newSoiBody","newReferenceFrame","getReferenceFrame","ReferenceFrameFactory","buildId","id","ReferenceFrame","INERTIAL_ECLIPTIC","newSoiState","stateVectorFromBaseReferenceFrameByEpoch","traj","TrajectoryKeplerianBasic","createFromState","physicalModel","minEpoch","setVisualModel","VisualTrajectoryModelKeplerian","color","visualModel","config","impulseVector","state","add_","Quaternion","twoAxis","rotate_","ModulePatchedConics","root","addPropagator","Events","addListener","LOADING_BODIES_DONE","fillSoiTree","VisualFlightEventSOIArrival","preloadTexture","VisualFlightEventSOIDeparture","ss","bodyId","objects","obj","Body","parentSoiId","body1","body2","chain1","indexOf","idx","period1","period2","relativePeriod"],"mappings":"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","file":"static/js/3.e1653939.chunk.js","sourcesContent":["export default class Module\r\n{\r\n    constructor() {\r\n        this._classes = {};\r\n    }\r\n\r\n    _addClass(alias, className) {\r\n        this._classes[alias] = className;\r\n    }\r\n\r\n    getClass(alias) {\r\n        if (this._classes[alias] === undefined) {\r\n            throw new Error('Unknown module class: ' + alias);\r\n        }\r\n        return this._classes[alias];\r\n    }\r\n\r\n    init() {}\r\n}\r\n","export default class PropagatorAbstract\r\n{\r\n    propagate(trajectory, epochFrom, stopCondition) {}\r\n}","import PropagatorAbstract from \"../../core/Propagator/Abstract\";\r\nimport TrajectoryComposite from \"../../core/Trajectory/Composite\";\r\nimport ReferenceFrameFactory, {ReferenceFrame} from \"../../core/ReferenceFrame/Factory\";\r\nimport TrajectoryKeplerianBasic from \"../../core/Trajectory/KeplerianBasic\";\r\nimport KeplerianObject from \"../../core/KeplerianObject\";\r\nimport VisualTrajectoryModelKeplerian from \"../../core/visual/Trajectory/Keplerian\";\r\nimport {getAngleIntervalsIntersection, getEpochIntervalsIntersection, Quaternion, TWO_PI} from \"../../core/algebra\";\r\nimport { sim } from \"../../core/Simulation\";\r\nimport FlightEventSOIArrival from \"./FlightEvent/SOIArrival\";\r\nimport FlightEventSOIDeparture from \"./FlightEvent/SOIDeparture\";\r\nimport EphemerisObject from \"../../core/EphemerisObject\";\r\nimport TrajectoryDynamic from \"../../core/Trajectory/Dynamic\";\r\nimport FlightEventImpulsiveBurn from \"../../core/FlightEvent/ImpulsiveBurn\";\r\n// import VisualPoint from \"../../visual/Point\";\r\n// import Constant from \"../../core/FunctionOfEpoch/Constant\";\r\n\r\nexport default class PropagatorPatchedConics extends PropagatorAbstract\r\n{\r\n    constructor() {\r\n        super();\r\n        this.soiSafetyCoefficient = 1.5;\r\n        this.maxPatchError = 1e-3; // 1 meter\r\n        // this.debugPoints = [];\r\n    }\r\n\r\n    propagate(trajectory, epochFrom) {\r\n        if (!trajectory instanceof TrajectoryDynamic) {\r\n            throw new Error('Patched conics propagation requires TrajectoryDynamic instance');\r\n        }\r\n\r\n        trajectory.clearAfterEpoch(epochFrom);\r\n\r\n        let burns = trajectory.flightEvents.filter(event => event instanceof FlightEventImpulsiveBurn && event.epoch >= epochFrom);\r\n        let curBurn = 0;\r\n        let nextBurnTime = burns.length > 0 ? burns[0].epoch : false;\r\n        let lastComponent = trajectory.getComponentByEpoch(epochFrom);\r\n        let epoch = Math.max(epochFrom, lastComponent.epoch);\r\n        let nextComponentData = false;\r\n\r\n        lastComponent.maxEpoch = false;\r\n/*\r\n        for (let point of this.debugPoints) {\r\n            point.drop();\r\n        }\r\n        this.debugPoints = [];\r\n*/\r\n        // console.log('Propagating...');\r\n\r\n        do {\r\n            // console.log('\\tLooking for next component...');\r\n            if (nextBurnTime !== epoch) {\r\n                nextComponentData = this._findNextTrajectory(lastComponent, epoch + 1, nextBurnTime);\r\n            }\r\n\r\n            if (nextComponentData) {\r\n                // console.log('\\tComponent found', nextComponentData);\r\n                trajectory.addComponent(nextComponentData.trajectory);\r\n\r\n                lastComponent.addFlightEvent(new FlightEventSOIDeparture(\r\n                    nextComponentData.epoch,\r\n                    nextComponentData.oldSoi,\r\n                    nextComponentData.newSoi\r\n                ));\r\n\r\n                epoch = nextComponentData.epoch;\r\n                lastComponent.maxEpoch = epoch;\r\n                lastComponent = nextComponentData.trajectory;\r\n\r\n                lastComponent.addFlightEvent(new FlightEventSOIArrival(\r\n                    nextComponentData.epoch,\r\n                    nextComponentData.oldSoi,\r\n                    nextComponentData.newSoi\r\n                ));\r\n            } else if (nextBurnTime !== false) {\r\n                lastComponent.maxEpoch = nextBurnTime;\r\n                lastComponent = this._createAfterBurnTrajectory(lastComponent, burns[curBurn].vector, nextBurnTime);\r\n                trajectory.addComponent(lastComponent);\r\n                nextComponentData = true;\r\n\r\n                curBurn += 1;\r\n                nextBurnTime = (burns[curBurn] !== undefined) ? burns[curBurn].epoch : false;\r\n            }\r\n\r\n        } while (nextComponentData);\r\n        // console.log('Propagation ended');\r\n    }\r\n\r\n    _findNextTrajectory(trajectory, epochFrom, epochTo) {\r\n        const soi = sim.starSystem.getObject(trajectory.referenceFrame.originId);\r\n        const ownSoiCrossing   = (soi.type !== EphemerisObject.TYPE_STAR)\r\n            ? this._findOwnSoiCrossing(soi, trajectory, epochFrom)\r\n            : false;\r\n        const childSoiCrossing = this._findChildSoiCrossing(\r\n            soi,\r\n            trajectory,\r\n            epochFrom,\r\n            (epochTo === false)\r\n                ? epochFrom + trajectory.period\r\n                : epochTo\r\n        );\r\n\r\n        if (childSoiCrossing === false && ownSoiCrossing === false) {\r\n            return false;\r\n        }\r\n\r\n        let nextSoiCrossing = (!childSoiCrossing || (ownSoiCrossing && ownSoiCrossing.epoch < childSoiCrossing.epoch))\r\n            ? ownSoiCrossing\r\n            : childSoiCrossing;\r\n\r\n        if (epochTo !== false && nextSoiCrossing.epoch > epochTo) {\r\n            return false;\r\n        }\r\n\r\n        return {\r\n            trajectory: this._createNextSoiTrajectory(trajectory, nextSoiCrossing.newSoi, nextSoiCrossing.epoch),\r\n            oldSoi: soi,\r\n            newSoi: nextSoiCrossing.newSoi,\r\n            epoch: nextSoiCrossing.epoch\r\n        };\r\n    }\r\n\r\n    _findOwnSoiCrossing(parent, trajectory, epochFrom) {\r\n        const ko = trajectory.keplerianObject;\r\n        const sphereCrossing = ko.getSphereCrossingTrueAnomaly(parent.data.patchedConics.soiRadius);\r\n\r\n        if (!sphereCrossing) {\r\n            return false;\r\n        }\r\n\r\n        let epoch = ko.getEpochByTrueAnomaly(sphereCrossing[0]);\r\n        while (epoch < epochFrom) {\r\n            epoch += ko.period;\r\n        }\r\n\r\n        return {\r\n            epoch: epoch,\r\n            newSoi: parent.data.patchedConics.parentSoi\r\n        };\r\n    }\r\n\r\n    _findChildSoiCrossing(parent, trajectory, epochFrom, epochTo) {\r\n        const ko = trajectory.keplerianObject;\r\n        let crossings = [];\r\n\r\n        if (ko.isHyperbolic && epochFrom === epochTo) {\r\n            let maxDistance = 0;\r\n            for (let soi of parent.data.patchedConics.childSois) {\r\n                const distance = soi.trajectory\r\n                    .getKeplerianObjectByEpoch(epochFrom, trajectory.referenceFrame)\r\n                    .getApoapsisRadius() + soi.data.patchedConics.soiRadius * this.soiSafetyCoefficient;\r\n                if (distance > maxDistance) {\r\n                    maxDistance = distance;\r\n                }\r\n            }\r\n            if (maxDistance === 0) {\r\n                return false;\r\n            }\r\n            const ta = ko.getSphereCrossingTrueAnomaly(maxDistance);\r\n            epochTo = ko.getEpochByTrueAnomaly(ta[0]);\r\n        }\r\n\r\n        for (let soi of parent.data.patchedConics.childSois) {\r\n            const childKo = soi.trajectory.getKeplerianObjectByEpoch(epochFrom, trajectory.referenceFrame);\r\n            const soiRadius = soi.data.patchedConics.soiRadius;\r\n            const intervals1 = this._getPotentialApproachIntervals(childKo, ko, epochFrom, epochTo, soiRadius * this.soiSafetyCoefficient);\r\n            if (intervals1 === false) {\r\n                continue;\r\n            }\r\n\r\n            const intervals2 = this._getPotentialApproachIntervals(ko, childKo, epochFrom, epochTo, soiRadius * this.soiSafetyCoefficient);\r\n/*\r\n            if (this.debugPoints.length === 0) {\r\n                if (intervals1 && intervals1 instanceof Array)\r\n                    for (let interval of intervals1) {\r\n                        this.debugPoints.push(new VisualPoint(new Constant(trajectory.getPositionByEpoch(interval[0], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'blue', 6));\r\n                        this.debugPoints.push(new VisualPoint(new Constant(trajectory.getPositionByEpoch(interval[1], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'blue', 10));\r\n                    }\r\n\r\n                if (intervals2 && intervals2 instanceof Array)\r\n                    for (let interval of intervals2) {\r\n                        this.debugPoints.push(new VisualPoint(new Constant(soi.trajectory.getPositionByEpoch(interval[0], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'yellow', 6));\r\n                        this.debugPoints.push(new VisualPoint(new Constant(soi.trajectory.getPositionByEpoch(interval[1], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'yellow', 10));\r\n                    }\r\n            }\r\n*/\r\n            let potentialApproachIntervals = getEpochIntervalsIntersection(intervals1, intervals2);\r\n\r\n            if (potentialApproachIntervals === false) {\r\n                continue;\r\n            }\r\n            if (potentialApproachIntervals === true) {\r\n                potentialApproachIntervals = [[epochFrom, epochTo]];\r\n            }\r\n\r\n            // Sorting the intervals so we can break the loop when we\r\n            // see an encounter and be sure that it's a closest one\r\n            potentialApproachIntervals.sort((i1, i2) => (i1[0] < i2[0]) ? -1 : (i1[0] > i2[0] ? 1 : 0));\r\n\r\n            // console.log('\\t\\tIteration started, SOI', soiRadius);\r\n            for (let interval of potentialApproachIntervals) {\r\n                if (interval[0] > epochTo) {\r\n                    break;\r\n                }\r\n                if (interval[1] < epochFrom) {\r\n                    continue;\r\n                }\r\n                if (interval[0] < epochFrom) {\r\n                    interval[0] = epochFrom;\r\n                }\r\n                if (interval[1] > epochTo) {\r\n                    interval[1] = epochTo;\r\n                }\r\n                let step = (ko.isElliptic && childKo.isElliptic)\r\n                    ? Math.min(Math.min(ko.period, childKo.period), interval[1] - interval[0]) / 10\r\n                    : (interval[1] - interval[0]) / 10;\r\n                let t1, t2, t = interval[0];\r\n                let prevDR = false;\r\n                let found = false;\r\n\r\n                // Distance between two objects, km\r\n                const getR = (states) => {\r\n                    return states[0].position.sub_(states[1]._position).mag;\r\n                };\r\n                // Distance derivative - rate of change of the distance between two objects, km/s\r\n                const getDR = (states, r) => {\r\n                    return (states[0]._position.mag * states[0]._velocity.projectionOn(states[0]._position)\r\n                          + states[1]._position.mag * states[1]._velocity.projectionOn(states[1]._position)\r\n                          - states[1]._position.dot(states[0]._velocity)\r\n                          - states[0]._position.dot(states[1]._velocity)) / r;\r\n                };\r\n                const getStates = (t) => [\r\n                    trajectory.getStateInOwnFrameByEpoch(t),\r\n                    soi.getStateByEpoch(t, trajectory.referenceFrame)\r\n                ];\r\n\r\n                // console.log('\\t\\t\\tInterval', interval[1] - interval[0], 'step', step);\r\n\r\n                // Purpose of this loop is to find a point inside soi\r\n                // (epoch t2) and a point outside the soi (epoch t1),\r\n                // where t1 < t2, or establish that there's no such point.\r\n                while (t < interval[1]) {\r\n                    let states = getStates(t);\r\n                    let r = getR(states);\r\n\r\n                    // console.log('\\t\\t\\t\\tStep start, t:', t - interval[0], 'R', r, 'dR', getDR(states, r), 'R+1', getR(getStates(t+1)));\r\n\r\n                    if (r < soiRadius) {\r\n                        t1 = t - step;\r\n                        t2 = t;\r\n                        found = true;\r\n                        // console.log('\\t\\t\\t\\t\\tFound 1');\r\n                        break;\r\n                    }\r\n\r\n                    let dR = getDR(states, r);\r\n\r\n                    // If the distance was decreasing on the last step and now it's increasing\r\n                    // then we just passed local minimum, so wee need to find it and check.\r\n                    // We're looking for the minimum in a loop. We break that loop when we\r\n                    // find a distance smaller than soiRadius or we find the minimum and\r\n                    // it's bigger than soiRadius which means there's no encounter.\r\n                    if (prevDR !== false && prevDR < 0 && dR > 0) {\r\n                        t1 = t - step;\r\n                        t2 = t;\r\n                        let t0, dR0;\r\n                        let dR1 = prevDR; // dR1 is always negative\r\n                        let dR2 = dR;     // dR1 is always positive\r\n\r\n                        // console.log('\\t\\t\\t\\t\\tPassed minimum, looking for it');\r\n\r\n                        do {\r\n                            t0 = t1 + (t2 - t1) * dR1 / (dR1 - dR2);\r\n\r\n                            states = getStates(t0);\r\n                            r = getR(states);\r\n\r\n                            // console.log('\\t\\t\\t\\t\\t\\tt0', t0, 'R', r, 'dR', getDR(states, r));\r\n\r\n                            if (r < soiRadius) {\r\n                                t2 = t0;\r\n                                found = true;\r\n                                // console.log('\\t\\t\\t\\t\\t\\t\\tFound 2');\r\n                                break;\r\n                            }\r\n\r\n                            dR0 = getDR(states, r);\r\n\r\n                            if (dR0 > 0) {\r\n                                t2 = t0;\r\n                                dR2 = dR0;\r\n                            } else {\r\n                                t1 = t0;\r\n                                dR1 = dR0;\r\n                            }\r\n\r\n                            // console.log('\\t\\t\\t\\t\\t\\tt1', t1, 't2', t2);\r\n                        // Local minimum condition:\r\n                        // distance derivative is smaller than 1 mm/s\r\n                        // or t2 - t1 is smaller than 1 second\r\n                        } while (Math.abs(dR0) > 1e-6 && (t2 - t1 > 1));\r\n\r\n                        if (found) {\r\n                            break;\r\n                        }\r\n\r\n                        // console.log('\\t\\t\\t\\t\\tMinimum is greater than soiRadius');\r\n                    }\r\n\r\n                    prevDR = dR;\r\n                    t += step;\r\n                } // iterating interval end\r\n\r\n                // At his point we have three relevant variables:\r\n                // `found` indicates whether or not we found a point\r\n                // inside soi, and if we did we have epoch `t2` inside\r\n                // soi and `t1` outside soi where `t1` < `t2`. Also, `t1`\r\n                // may be less than `interval[0]`, which means we\r\n                // encountered a point inside soi on the very first step\r\n\r\n                if (!found) {\r\n                    continue;\r\n                }\r\n\r\n                if (t1 < interval[0]) {\r\n                    crossings.push({\r\n                        epoch: interval[0],\r\n                        newSoi: soi\r\n                    });\r\n                    break;\r\n                }\r\n\r\n                let d;\r\n                let d1 = getR(getStates(t1)) - soiRadius; // d1 is always positive\r\n                let d2 = getR(getStates(t2)) - soiRadius; // d2 is always negative\r\n\r\n                do {\r\n                    t = t1 + (t2 - t1) * d1 / (d1 - d2);\r\n\r\n                    d = getR(getStates(t)) - soiRadius;\r\n\r\n                    if (d < 0) {\r\n                        t2 = t;\r\n                        d2 = d;\r\n                    } else {\r\n                        t1 = t;\r\n                        d1 = d;\r\n                    }\r\n                } while (Math.abs(d) > this.maxPatchError);\r\n\r\n                crossings.push({\r\n                    epoch: t,\r\n                    newSoi: soi\r\n                });\r\n                break;\r\n\r\n            } // intervals loop end\r\n        } // soi loop end\r\n\r\n        if (!crossings.length) {\r\n            return false;\r\n        }\r\n\r\n        let closestCrossing = crossings[0];\r\n        for (let crossing of crossings) {\r\n            if (crossing.epoch < closestCrossing.epoch) {\r\n                closestCrossing = crossing;\r\n            }\r\n        }\r\n\r\n        return closestCrossing;\r\n    }\r\n\r\n    _getPotentialApproachIntervals(keplerianObjectBase, keplerianObjectActive, epochFrom, epochTo, distance) {\r\n        const radialTa = this._getRadialTaBounds(keplerianObjectBase, keplerianObjectActive, distance);\r\n        if (radialTa === false) {\r\n            return false;\r\n        }\r\n\r\n        const verticalTa = this._getVerticalTaBounds(keplerianObjectBase, keplerianObjectActive, distance);\r\n        let taIntervals;\r\n\r\n        if (verticalTa) {\r\n            taIntervals = getAngleIntervalsIntersection(verticalTa, radialTa);\r\n        } else {\r\n            if (radialTa === true) {\r\n                return true;\r\n            } else {\r\n                taIntervals = radialTa;\r\n            }\r\n        }\r\n\r\n        if (taIntervals === false) {\r\n            return false;\r\n        }\r\n\r\n        const period = keplerianObjectActive.period;\r\n        let inEpoch, outEpoch;\r\n        let adding = keplerianObjectActive.isElliptic\r\n            ? Math.floor((epochFrom - keplerianObjectActive.epoch) / period) * period\r\n            : 0;\r\n        let maxProcessedEpoch = 0;\r\n        let epochIntervals = [];\r\n\r\n        do {\r\n            for (let taInterval of taIntervals) {\r\n                inEpoch = keplerianObjectActive.getEpochByTrueAnomaly(taInterval[0]) + adding;\r\n                outEpoch = keplerianObjectActive.getEpochByTrueAnomaly(taInterval[1]) + adding;\r\n\r\n                if (outEpoch < inEpoch) {\r\n                    inEpoch -= period;\r\n                }\r\n\r\n                if (outEpoch > maxProcessedEpoch) {\r\n                    maxProcessedEpoch = outEpoch;\r\n                }\r\n                if (outEpoch < epochFrom) {\r\n                    continue;\r\n                }\r\n\r\n                if (epochIntervals.length > 10000) {\r\n                    throw new Error('Infinite loop detected');\r\n                }\r\n\r\n                epochIntervals.push([inEpoch, outEpoch]);\r\n            }\r\n            adding += period;\r\n\r\n        } while (maxProcessedEpoch < epochTo && keplerianObjectActive.isElliptic);\r\n\r\n        return epochIntervals;\r\n    }\r\n\r\n    _getVerticalTaBounds(keplerianObjectBase, keplerianObjectActive, distance) {\r\n        // this is only to recalculate inc, raan and aop. probably can be optimized.\r\n        const baseNormal = keplerianObjectBase.getNormalVector();\r\n        const activeNormal = keplerianObjectActive.getNormalVector();\r\n        const equinoxVector = keplerianObjectBase.getPeriapsisVector();\r\n        const raanVector = baseNormal.cross(activeNormal);\r\n        const periapsisVector = keplerianObjectActive.getPeriapsisVector();\r\n\r\n        const inc = baseNormal.angle(activeNormal);\r\n        let raan = raanVector.angle(equinoxVector);\r\n        if (equinoxVector.cross(raanVector).angle(baseNormal) > Math.PI / 2) {\r\n            raan = TWO_PI - raan;\r\n        }\r\n        let aop = raanVector.angle(periapsisVector);\r\n        if (raanVector.cross(periapsisVector).angle(activeNormal) > Math.PI / 2) {\r\n            aop = TWO_PI - aop;\r\n        }\r\n\r\n        const relKeplerianObject = new KeplerianObject(\r\n            keplerianObjectActive.ecc,\r\n            keplerianObjectActive.sma,\r\n            aop,\r\n            inc,\r\n            raan,\r\n            keplerianObjectActive.m0,\r\n            keplerianObjectActive.epoch,\r\n            keplerianObjectActive.mu,\r\n            false\r\n        );\r\n\r\n        return relKeplerianObject.getPlaneCrossingTrueAnomaly(distance);\r\n    }\r\n\r\n    _getRadialTaBounds(keplerianObjectBase, keplerianObjectActive, distance) {\r\n        const r1 = keplerianObjectBase.getPeriapsisRadius() - distance;\r\n        const r2 = keplerianObjectBase.getApoapsisRadius()  + distance;\r\n        const radialTa1 = keplerianObjectActive.getSphereCrossingTrueAnomaly(r1);\r\n        const radialTa2 = keplerianObjectActive.getSphereCrossingTrueAnomaly(r2);\r\n\r\n        if (keplerianObjectBase.isHyperbolic) {\r\n            if (keplerianObjectActive.isHyperbolic) {\r\n                return radialTa1\r\n                    ? [[-Infinity, radialTa1[1] - TWO_PI],[radialTa1[0], Infinity]]\r\n                    : true;\r\n            } else {\r\n                return radialTa1\r\n                    ? [radialTa1]\r\n                    : (keplerianObjectActive.getApoapsisRadius() >= r1);\r\n            }\r\n        }\r\n        // keplerianObjectBase is elliptic\r\n\r\n        if (keplerianObjectActive.isHyperbolic) {\r\n            if (!radialTa2) {\r\n                return false;\r\n            } else if (!radialTa1) {\r\n                return [[radialTa2[1] - TWO_PI, radialTa2[0]]];\r\n            }\r\n            return [\r\n                [radialTa2[1] - TWO_PI, radialTa1[1] - TWO_PI],\r\n                [radialTa1[0], radialTa2[0]],\r\n            ];\r\n        }\r\n        // keplerianObjectActive is elliptic\r\n\r\n        if (radialTa1) {\r\n            return radialTa2\r\n                ? [[radialTa1[0], radialTa2[0]], [radialTa2[1], radialTa1[1]]]\r\n                : [radialTa1];\r\n        } else if (radialTa2) {\r\n            return [[radialTa2[1], radialTa2[0]]];\r\n        }\r\n        return keplerianObjectActive.getPeriapsisRadius() < r2\r\n            && keplerianObjectActive.getApoapsisRadius()  > r1;\r\n    }\r\n\r\n    _createNextSoiTrajectory(originalTrajectory, newSoiBody, epoch) {\r\n        let newReferenceFrame = sim.starSystem.getReferenceFrame(ReferenceFrameFactory.buildId(newSoiBody.id, ReferenceFrame.INERTIAL_ECLIPTIC));\r\n        let newSoiState = newReferenceFrame.stateVectorFromBaseReferenceFrameByEpoch(\r\n            epoch,\r\n            originalTrajectory.getStateByEpoch(epoch)\r\n        );\r\n\r\n        let traj = new TrajectoryKeplerianBasic(\r\n            newReferenceFrame.id,\r\n            KeplerianObject.createFromState(\r\n                newSoiState,\r\n                newSoiBody.physicalModel.mu,\r\n                epoch\r\n            )\r\n        );\r\n        traj.minEpoch = epoch;\r\n        traj.maxEpoch = false;\r\n\r\n        // TODO refactor this\r\n        traj.setVisualModel(new VisualTrajectoryModelKeplerian(\r\n            traj,\r\n            {color: originalTrajectory.visualModel.config.color, minEpoch: false, maxEpoch: 'copy'}\r\n        ));\r\n\r\n        return traj;\r\n    }\r\n\r\n    _createAfterBurnTrajectory(originalTrajectory, impulseVector, epoch) {\r\n        let state = originalTrajectory.getStateInOwnFrameByEpoch(epoch);\r\n        state._velocity.add_(\r\n            Quaternion.twoAxis(state._velocity, null, state._position)\r\n                .rotate_(impulseVector)\r\n        );\r\n\r\n        let traj = new TrajectoryKeplerianBasic(\r\n            originalTrajectory.referenceFrame.id,\r\n            KeplerianObject.createFromState(\r\n                state,\r\n                originalTrajectory.mu,\r\n                epoch\r\n            )\r\n        );\r\n        traj.minEpoch = epoch;\r\n        traj.maxEpoch = false;\r\n\r\n        // TODO refactor this\r\n        traj.setVisualModel(new VisualTrajectoryModelKeplerian(\r\n            traj,\r\n            {color: originalTrajectory.visualModel.config.color, minEpoch: false, maxEpoch: 'copy'}\r\n        ));\r\n\r\n        return traj;\r\n    }\r\n}\r\n","import Module from \"../../core/Module\";\r\nimport Events from \"../../core/Events\";\r\nimport EphemerisObject from \"../../core/EphemerisObject\";\r\nimport Body from \"../../core/Body\";\r\nimport PropagatorPatchedConics from \"./PropagatorPatchedConics\";\r\nimport { sim } from \"../../core/Simulation\";\r\nimport VisualFlightEventSOIArrival from \"./visual/FlightEvent/SOIArrival\";\r\nimport VisualFlightEventSOIDeparture from \"./visual/FlightEvent/SOIDeparture\";\r\n\r\nexport default class ModulePatchedConics extends Module\r\n{\r\n    init() {\r\n        this.root = null;\r\n\r\n        sim.addPropagator('patchedConics', PropagatorPatchedConics);\r\n        Events.addListener(Events.LOADING_BODIES_DONE, () => this.fillSoiTree());\r\n        if (sim.starSystem) {\r\n            this.fillSoiTree();\r\n        }\r\n\r\n        VisualFlightEventSOIArrival.preloadTexture();\r\n        VisualFlightEventSOIDeparture.preloadTexture();\r\n    }\r\n\r\n    fillSoiTree() {\r\n        let ss = sim.starSystem;\r\n\r\n        for (let bodyId in ss.objects) {\r\n            let obj = ss.objects[bodyId];\r\n            if (!(obj instanceof Body) || obj.data.patchedConics === undefined)\r\n                continue;\r\n\r\n            if (obj.type === EphemerisObject.TYPE_STAR)\r\n                this.root = obj;\r\n\r\n            let parent = ss.getObject(obj.data.patchedConics.parentSoiId);\r\n\r\n            if (!(parent instanceof Body)) {\r\n                continue;\r\n            }\r\n\r\n            obj.data.patchedConics.parentSoi = parent;\r\n            parent.data.patchedConics.childSois.push(obj);\r\n        }\r\n    }\r\n\r\n    getRootSoi() {\r\n        return this.root;\r\n    }\r\n\r\n    getCommonParent(body1, body2) {\r\n        let chain1 = [body1];\r\n        let parent;\r\n\r\n        while (parent = sim.starSystem.getObject(chain1[chain1.length - 1]).data.patchedConics.parentSoiId) {\r\n            chain1.push(parent);\r\n        }\r\n\r\n        parent = body2;\r\n        do {\r\n            if (chain1.indexOf(parent) !== -1) {\r\n                return sim.starSystem.getObject(parent);\r\n            }\r\n            parent = sim.starSystem.getObject(parent).data.patchedConics.parentSoiId;\r\n        } while (parent);\r\n\r\n        return null;\r\n    }\r\n\r\n    getRelativePeriod(body1, body2, epoch) {\r\n        let chain1 = [body1];\r\n        let parent, idx;\r\n\r\n        while (parent = sim.starSystem.getObject(chain1[chain1.length - 1]).data.patchedConics.parentSoiId) {\r\n            if (parent == body2) {\r\n                return null;\r\n            }\r\n            chain1.push(parent);\r\n        }\r\n\r\n        let obj = body2;\r\n        while (parent = sim.starSystem.getObject(obj).data.patchedConics.parentSoiId) {\r\n            if ((idx = chain1.indexOf(parent)) !== -1) {\r\n                if (idx === 0) {\r\n                    return null;\r\n                }\r\n\r\n                let period1 = sim.starSystem.getObject(chain1[idx - 1]).trajectory.getKeplerianObjectByEpoch(epoch).period;\r\n                let period2 = sim.starSystem.getObject(obj).trajectory.getKeplerianObjectByEpoch(epoch).period;\r\n\r\n                return {\r\n                    period1: period1,\r\n                    period2: period2,\r\n                    relativePeriod: 1 / Math.abs(1 / period1 - 1 / period2)\r\n                };\r\n            }\r\n            obj = parent;\r\n        }\r\n\r\n        return null;\r\n\r\n    }\r\n}\r\n"],"sourceRoot":""}