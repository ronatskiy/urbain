{"version":3,"sources":["core/Propagator/Abstract.js","modules/PatchedConics/PropagatorPatchedConics.js"],"names":["PropagatorAbstract","trajectory","epochFrom","stopCondition","PropagatorPatchedConics","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","soiSafetyCoefficient","maxPatchError","TrajectoryDynamic","Error","clearAfterEpoch","burns","flightEvents","filter","event","FlightEventImpulsiveBurn","epoch","curBurn","nextBurnTime","length","lastComponent","getComponentByEpoch","Math","max","nextComponentData","maxEpoch","_findNextTrajectory","addComponent","addFlightEvent","FlightEventSOIDeparture","oldSoi","newSoi","FlightEventSOIArrival","_createAfterBurnTrajectory","vector","undefined","epochTo","soi","sim","starSystem","getObject","referenceFrame","originId","ownSoiCrossing","type","EphemerisObject","TYPE_STAR","_findOwnSoiCrossing","childSoiCrossing","_findChildSoiCrossing","period","nextSoiCrossing","_createNextSoiTrajectory","parent","ko","keplerianObject","sphereCrossing","getSphereCrossingTrueAnomaly","data","patchedConics","soiRadius","getEpochByTrueAnomaly","parentSoi","_this2","crossings","isHyperbolic","maxDistance","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","childSois","Symbol","iterator","next","done","value","distance","getKeplerianObjectByEpoch","getApoapsisRadius","err","return","ta","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_loop","childKo","intervals1","_getPotentialApproachIntervals","intervals2","potentialApproachIntervals","getEpochIntervalsIntersection","sort","i1","i2","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","interval","step","isElliptic","min","t1","t2","t","prevDR","found","getR","states","position","sub_","_position","mag","getDR","r","_velocity","projectionOn","dot","getStates","getStateInOwnFrameByEpoch","getStateByEpoch","dR","t0","dR0","dR1","dR2","abs","push","d","d1","d2","_iterator2","closestCrossing","_i","crossing","keplerianObjectBase","keplerianObjectActive","radialTa","_getRadialTaBounds","taIntervals","verticalTa","_getVerticalTaBounds","getAngleIntervalsIntersection","inEpoch","outEpoch","adding","floor","maxProcessedEpoch","epochIntervals","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","taInterval","baseNormal","getNormalVector","activeNormal","equinoxVector","getPeriapsisVector","raanVector","cross","periapsisVector","inc","angle","raan","PI","TWO_PI","aop","KeplerianObject","ecc","sma","m0","mu","getPlaneCrossingTrueAnomaly","r1","getPeriapsisRadius","r2","radialTa1","radialTa2","Infinity","originalTrajectory","newSoiBody","newReferenceFrame","getReferenceFrame","ReferenceFrameFactory","buildId","id","ReferenceFrame","INERTIAL_ECLIPTIC","newSoiState","stateVectorFromBaseReferenceFrameByEpoch","traj","TrajectoryKeplerianBasic","createFromState","physicalModel","minEpoch","setVisualModel","VisualTrajectoryModelKeplerian","color","visualModel","config","impulseVector","state","add_","Quaternion","twoAxis","rotate_"],"mappings":"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","file":"static/js/4.5a26edf8.chunk.js","sourcesContent":["export default class PropagatorAbstract\r\n{\r\n    propagate(trajectory, epochFrom, stopCondition) {}\r\n}","import PropagatorAbstract from \"../../core/Propagator/Abstract\";\r\nimport TrajectoryComposite from \"../../core/Trajectory/Composite\";\r\nimport ReferenceFrameFactory, {ReferenceFrame} from \"../../core/ReferenceFrame/Factory\";\r\nimport TrajectoryKeplerianBasic from \"../../core/Trajectory/KeplerianBasic\";\r\nimport KeplerianObject from \"../../core/KeplerianObject\";\r\nimport VisualTrajectoryModelKeplerian from \"../../core/visual/Trajectory/Keplerian\";\r\nimport {getAngleIntervalsIntersection, getEpochIntervalsIntersection, Quaternion, TWO_PI} from \"../../core/algebra\";\r\nimport { sim } from \"../../core/Simulation\";\r\nimport FlightEventSOIArrival from \"./FlightEvent/SOIArrival\";\r\nimport FlightEventSOIDeparture from \"./FlightEvent/SOIDeparture\";\r\nimport EphemerisObject from \"../../core/EphemerisObject\";\r\nimport TrajectoryDynamic from \"../../core/Trajectory/Dynamic\";\r\nimport FlightEventImpulsiveBurn from \"../../core/FlightEvent/ImpulsiveBurn\";\r\n// import VisualPoint from \"../../visual/Point\";\r\n// import Constant from \"../../core/FunctionOfEpoch/Constant\";\r\n\r\nexport default class PropagatorPatchedConics extends PropagatorAbstract\r\n{\r\n    constructor() {\r\n        super();\r\n        this.soiSafetyCoefficient = 1.5;\r\n        this.maxPatchError = 1e-3; // 1 meter\r\n        // this.debugPoints = [];\r\n    }\r\n\r\n    propagate(trajectory, epochFrom) {\r\n        if (!trajectory instanceof TrajectoryDynamic) {\r\n            throw new Error('Patched conics propagation requires TrajectoryDynamic instance');\r\n        }\r\n\r\n        trajectory.clearAfterEpoch(epochFrom);\r\n\r\n        let burns = trajectory.flightEvents.filter(event => event instanceof FlightEventImpulsiveBurn && event.epoch >= epochFrom);\r\n        let curBurn = 0;\r\n        let nextBurnTime = burns.length > 0 ? burns[0].epoch : false;\r\n        let lastComponent = trajectory.getComponentByEpoch(epochFrom);\r\n        let epoch = Math.max(epochFrom, lastComponent.epoch);\r\n        let nextComponentData = false;\r\n\r\n        lastComponent.maxEpoch = false;\r\n/*\r\n        for (let point of this.debugPoints) {\r\n            point.drop();\r\n        }\r\n        this.debugPoints = [];\r\n*/\r\n        // console.log('Propagating...');\r\n\r\n        do {\r\n            // console.log('\\tLooking for next component...');\r\n            if (nextBurnTime !== epoch) {\r\n                nextComponentData = this._findNextTrajectory(lastComponent, epoch + 1, nextBurnTime);\r\n            }\r\n\r\n            if (nextComponentData) {\r\n                // console.log('\\tComponent found', nextComponentData);\r\n                trajectory.addComponent(nextComponentData.trajectory);\r\n\r\n                lastComponent.addFlightEvent(new FlightEventSOIDeparture(\r\n                    nextComponentData.epoch,\r\n                    nextComponentData.oldSoi,\r\n                    nextComponentData.newSoi\r\n                ));\r\n\r\n                epoch = nextComponentData.epoch;\r\n                lastComponent.maxEpoch = epoch;\r\n                lastComponent = nextComponentData.trajectory;\r\n\r\n                lastComponent.addFlightEvent(new FlightEventSOIArrival(\r\n                    nextComponentData.epoch,\r\n                    nextComponentData.oldSoi,\r\n                    nextComponentData.newSoi\r\n                ));\r\n            } else if (nextBurnTime !== false) {\r\n                lastComponent.maxEpoch = nextBurnTime;\r\n                lastComponent = this._createAfterBurnTrajectory(lastComponent, burns[curBurn].vector, nextBurnTime);\r\n                trajectory.addComponent(lastComponent);\r\n                nextComponentData = true;\r\n\r\n                curBurn += 1;\r\n                nextBurnTime = (burns[curBurn] !== undefined) ? burns[curBurn].epoch : false;\r\n            }\r\n\r\n        } while (nextComponentData);\r\n        // console.log('Propagation ended');\r\n    }\r\n\r\n    _findNextTrajectory(trajectory, epochFrom, epochTo) {\r\n        const soi = sim.starSystem.getObject(trajectory.referenceFrame.originId);\r\n        const ownSoiCrossing   = (soi.type !== EphemerisObject.TYPE_STAR)\r\n            ? this._findOwnSoiCrossing(soi, trajectory, epochFrom)\r\n            : false;\r\n        const childSoiCrossing = this._findChildSoiCrossing(\r\n            soi,\r\n            trajectory,\r\n            epochFrom,\r\n            (epochTo === false)\r\n                ? epochFrom + trajectory.period\r\n                : epochTo\r\n        );\r\n\r\n        if (childSoiCrossing === false && ownSoiCrossing === false) {\r\n            return false;\r\n        }\r\n\r\n        let nextSoiCrossing = (!childSoiCrossing || (ownSoiCrossing && ownSoiCrossing.epoch < childSoiCrossing.epoch))\r\n            ? ownSoiCrossing\r\n            : childSoiCrossing;\r\n\r\n        if (epochTo !== false && nextSoiCrossing.epoch > epochTo) {\r\n            return false;\r\n        }\r\n\r\n        return {\r\n            trajectory: this._createNextSoiTrajectory(trajectory, nextSoiCrossing.newSoi, nextSoiCrossing.epoch),\r\n            oldSoi: soi,\r\n            newSoi: nextSoiCrossing.newSoi,\r\n            epoch: nextSoiCrossing.epoch\r\n        };\r\n    }\r\n\r\n    _findOwnSoiCrossing(parent, trajectory, epochFrom) {\r\n        const ko = trajectory.keplerianObject;\r\n        const sphereCrossing = ko.getSphereCrossingTrueAnomaly(parent.data.patchedConics.soiRadius);\r\n\r\n        if (!sphereCrossing) {\r\n            return false;\r\n        }\r\n\r\n        let epoch = ko.getEpochByTrueAnomaly(sphereCrossing[0]);\r\n        while (epoch < epochFrom) {\r\n            epoch += ko.period;\r\n        }\r\n\r\n        return {\r\n            epoch: epoch,\r\n            newSoi: parent.data.patchedConics.parentSoi\r\n        };\r\n    }\r\n\r\n    _findChildSoiCrossing(parent, trajectory, epochFrom, epochTo) {\r\n        const ko = trajectory.keplerianObject;\r\n        let crossings = [];\r\n\r\n        if (ko.isHyperbolic && epochFrom === epochTo) {\r\n            let maxDistance = 0;\r\n            for (let soi of parent.data.patchedConics.childSois) {\r\n                const distance = soi.trajectory\r\n                    .getKeplerianObjectByEpoch(epochFrom, trajectory.referenceFrame)\r\n                    .getApoapsisRadius() + soi.data.patchedConics.soiRadius * this.soiSafetyCoefficient;\r\n                if (distance > maxDistance) {\r\n                    maxDistance = distance;\r\n                }\r\n            }\r\n            if (maxDistance === 0) {\r\n                return false;\r\n            }\r\n            const ta = ko.getSphereCrossingTrueAnomaly(maxDistance);\r\n            epochTo = ko.getEpochByTrueAnomaly(ta[0]);\r\n        }\r\n\r\n        for (let soi of parent.data.patchedConics.childSois) {\r\n            const childKo = soi.trajectory.getKeplerianObjectByEpoch(epochFrom, trajectory.referenceFrame);\r\n            const soiRadius = soi.data.patchedConics.soiRadius;\r\n            const intervals1 = this._getPotentialApproachIntervals(childKo, ko, epochFrom, epochTo, soiRadius * this.soiSafetyCoefficient);\r\n            if (intervals1 === false) {\r\n                continue;\r\n            }\r\n\r\n            const intervals2 = this._getPotentialApproachIntervals(ko, childKo, epochFrom, epochTo, soiRadius * this.soiSafetyCoefficient);\r\n/*\r\n            if (this.debugPoints.length === 0) {\r\n                if (intervals1 && intervals1 instanceof Array)\r\n                    for (let interval of intervals1) {\r\n                        this.debugPoints.push(new VisualPoint(new Constant(trajectory.getPositionByEpoch(interval[0], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'blue', 6));\r\n                        this.debugPoints.push(new VisualPoint(new Constant(trajectory.getPositionByEpoch(interval[1], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'blue', 10));\r\n                    }\r\n\r\n                if (intervals2 && intervals2 instanceof Array)\r\n                    for (let interval of intervals2) {\r\n                        this.debugPoints.push(new VisualPoint(new Constant(soi.trajectory.getPositionByEpoch(interval[0], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'yellow', 6));\r\n                        this.debugPoints.push(new VisualPoint(new Constant(soi.trajectory.getPositionByEpoch(interval[1], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'yellow', 10));\r\n                    }\r\n            }\r\n*/\r\n            let potentialApproachIntervals = getEpochIntervalsIntersection(intervals1, intervals2);\r\n\r\n            if (potentialApproachIntervals === false) {\r\n                continue;\r\n            }\r\n            if (potentialApproachIntervals === true) {\r\n                potentialApproachIntervals = [[epochFrom, epochTo]];\r\n            }\r\n\r\n            // Sorting the intervals so we can break the loop when we\r\n            // see an encounter and be sure that it's a closest one\r\n            potentialApproachIntervals.sort((i1, i2) => (i1[0] < i2[0]) ? -1 : (i1[0] > i2[0] ? 1 : 0));\r\n\r\n            // console.log('\\t\\tIteration started, SOI', soiRadius);\r\n            for (let interval of potentialApproachIntervals) {\r\n                if (interval[0] > epochTo) {\r\n                    break;\r\n                }\r\n                if (interval[1] < epochFrom) {\r\n                    continue;\r\n                }\r\n                if (interval[0] < epochFrom) {\r\n                    interval[0] = epochFrom;\r\n                }\r\n                if (interval[1] > epochTo) {\r\n                    interval[1] = epochTo;\r\n                }\r\n                let step = (ko.isElliptic && childKo.isElliptic)\r\n                    ? Math.min(Math.min(ko.period, childKo.period), interval[1] - interval[0]) / 10\r\n                    : (interval[1] - interval[0]) / 10;\r\n                let t1, t2, t = interval[0];\r\n                let prevDR = false;\r\n                let found = false;\r\n\r\n                // Distance between two objects, km\r\n                const getR = (states) => {\r\n                    return states[0].position.sub_(states[1]._position).mag;\r\n                };\r\n                // Distance derivative - rate of change of the distance between two objects, km/s\r\n                const getDR = (states, r) => {\r\n                    return (states[0]._position.mag * states[0]._velocity.projectionOn(states[0]._position)\r\n                          + states[1]._position.mag * states[1]._velocity.projectionOn(states[1]._position)\r\n                          - states[1]._position.dot(states[0]._velocity)\r\n                          - states[0]._position.dot(states[1]._velocity)) / r;\r\n                };\r\n                const getStates = (t) => [\r\n                    trajectory.getStateInOwnFrameByEpoch(t),\r\n                    soi.getStateByEpoch(t, trajectory.referenceFrame)\r\n                ];\r\n\r\n                // console.log('\\t\\t\\tInterval', interval[1] - interval[0], 'step', step);\r\n\r\n                // Purpose of this loop is to find a point inside soi\r\n                // (epoch t2) and a point outside the soi (epoch t1),\r\n                // where t1 < t2, or establish that there's no such point.\r\n                while (t < interval[1]) {\r\n                    let states = getStates(t);\r\n                    let r = getR(states);\r\n\r\n                    // console.log('\\t\\t\\t\\tStep start, t:', t - interval[0], 'R', r, 'dR', getDR(states, r), 'R+1', getR(getStates(t+1)));\r\n\r\n                    if (r < soiRadius) {\r\n                        t1 = t - step;\r\n                        t2 = t;\r\n                        found = true;\r\n                        // console.log('\\t\\t\\t\\t\\tFound 1');\r\n                        break;\r\n                    }\r\n\r\n                    let dR = getDR(states, r);\r\n\r\n                    // If the distance was decreasing on the last step and now it's increasing\r\n                    // then we just passed local minimum, so wee need to find it and check.\r\n                    // We're looking for the minimum in a loop. We break that loop when we\r\n                    // find a distance smaller than soiRadius or we find the minimum and\r\n                    // it's bigger than soiRadius which means there's no encounter.\r\n                    if (prevDR !== false && prevDR < 0 && dR > 0) {\r\n                        t1 = t - step;\r\n                        t2 = t;\r\n                        let t0, dR0;\r\n                        let dR1 = prevDR; // dR1 is always negative\r\n                        let dR2 = dR;     // dR1 is always positive\r\n\r\n                        // console.log('\\t\\t\\t\\t\\tPassed minimum, looking for it');\r\n\r\n                        do {\r\n                            t0 = t1 + (t2 - t1) * dR1 / (dR1 - dR2);\r\n\r\n                            states = getStates(t0);\r\n                            r = getR(states);\r\n\r\n                            // console.log('\\t\\t\\t\\t\\t\\tt0', t0, 'R', r, 'dR', getDR(states, r));\r\n\r\n                            if (r < soiRadius) {\r\n                                t2 = t0;\r\n                                found = true;\r\n                                // console.log('\\t\\t\\t\\t\\t\\t\\tFound 2');\r\n                                break;\r\n                            }\r\n\r\n                            dR0 = getDR(states, r);\r\n\r\n                            if (dR0 > 0) {\r\n                                t2 = t0;\r\n                                dR2 = dR0;\r\n                            } else {\r\n                                t1 = t0;\r\n                                dR1 = dR0;\r\n                            }\r\n\r\n                            // console.log('\\t\\t\\t\\t\\t\\tt1', t1, 't2', t2);\r\n                        // Local minimum condition:\r\n                        // distance derivative is smaller than 1 mm/s\r\n                        // or t2 - t1 is smaller than 1 second\r\n                        } while (Math.abs(dR0) > 1e-6 && (t2 - t1 > 1));\r\n\r\n                        if (found) {\r\n                            break;\r\n                        }\r\n\r\n                        // console.log('\\t\\t\\t\\t\\tMinimum is greater than soiRadius');\r\n                    }\r\n\r\n                    prevDR = dR;\r\n                    t += step;\r\n                } // iterating interval end\r\n\r\n                // At his point we have three relevant variables:\r\n                // `found` indicates whether or not we found a point\r\n                // inside soi, and if we did we have epoch `t2` inside\r\n                // soi and `t1` outside soi where `t1` < `t2`. Also, `t1`\r\n                // may be less than `interval[0]`, which means we\r\n                // encountered a point inside soi on the very first step\r\n\r\n                if (!found) {\r\n                    continue;\r\n                }\r\n\r\n                if (t1 < interval[0]) {\r\n                    crossings.push({\r\n                        epoch: interval[0],\r\n                        newSoi: soi\r\n                    });\r\n                    break;\r\n                }\r\n\r\n                let d;\r\n                let d1 = getR(getStates(t1)) - soiRadius; // d1 is always positive\r\n                let d2 = getR(getStates(t2)) - soiRadius; // d2 is always negative\r\n\r\n                do {\r\n                    t = t1 + (t2 - t1) * d1 / (d1 - d2);\r\n\r\n                    d = getR(getStates(t)) - soiRadius;\r\n\r\n                    if (d < 0) {\r\n                        t2 = t;\r\n                        d2 = d;\r\n                    } else {\r\n                        t1 = t;\r\n                        d1 = d;\r\n                    }\r\n                } while (Math.abs(d) > this.maxPatchError);\r\n\r\n                crossings.push({\r\n                    epoch: t,\r\n                    newSoi: soi\r\n                });\r\n                break;\r\n\r\n            } // intervals loop end\r\n        } // soi loop end\r\n\r\n        if (!crossings.length) {\r\n            return false;\r\n        }\r\n\r\n        let closestCrossing = crossings[0];\r\n        for (let crossing of crossings) {\r\n            if (crossing.epoch < closestCrossing.epoch) {\r\n                closestCrossing = crossing;\r\n            }\r\n        }\r\n\r\n        return closestCrossing;\r\n    }\r\n\r\n    _getPotentialApproachIntervals(keplerianObjectBase, keplerianObjectActive, epochFrom, epochTo, distance) {\r\n        const radialTa = this._getRadialTaBounds(keplerianObjectBase, keplerianObjectActive, distance);\r\n        if (radialTa === false) {\r\n            return false;\r\n        }\r\n\r\n        const verticalTa = this._getVerticalTaBounds(keplerianObjectBase, keplerianObjectActive, distance);\r\n        let taIntervals;\r\n\r\n        if (verticalTa) {\r\n            taIntervals = getAngleIntervalsIntersection(verticalTa, radialTa);\r\n        } else {\r\n            if (radialTa === true) {\r\n                return true;\r\n            } else {\r\n                taIntervals = radialTa;\r\n            }\r\n        }\r\n\r\n        if (taIntervals === false) {\r\n            return false;\r\n        }\r\n\r\n        const period = keplerianObjectActive.period;\r\n        let inEpoch, outEpoch;\r\n        let adding = keplerianObjectActive.isElliptic\r\n            ? Math.floor((epochFrom - keplerianObjectActive.epoch) / period) * period\r\n            : 0;\r\n        let maxProcessedEpoch = 0;\r\n        let epochIntervals = [];\r\n\r\n        do {\r\n            for (let taInterval of taIntervals) {\r\n                inEpoch = keplerianObjectActive.getEpochByTrueAnomaly(taInterval[0]) + adding;\r\n                outEpoch = keplerianObjectActive.getEpochByTrueAnomaly(taInterval[1]) + adding;\r\n\r\n                if (outEpoch < inEpoch) {\r\n                    inEpoch -= period;\r\n                }\r\n\r\n                if (outEpoch > maxProcessedEpoch) {\r\n                    maxProcessedEpoch = outEpoch;\r\n                }\r\n                if (outEpoch < epochFrom) {\r\n                    continue;\r\n                }\r\n\r\n                if (epochIntervals.length > 10000) {\r\n                    throw new Error('Infinite loop detected');\r\n                }\r\n\r\n                epochIntervals.push([inEpoch, outEpoch]);\r\n            }\r\n            adding += period;\r\n\r\n        } while (maxProcessedEpoch < epochTo && keplerianObjectActive.isElliptic);\r\n\r\n        return epochIntervals;\r\n    }\r\n\r\n    _getVerticalTaBounds(keplerianObjectBase, keplerianObjectActive, distance) {\r\n        // this is only to recalculate inc, raan and aop. probably can be optimized.\r\n        const baseNormal = keplerianObjectBase.getNormalVector();\r\n        const activeNormal = keplerianObjectActive.getNormalVector();\r\n        const equinoxVector = keplerianObjectBase.getPeriapsisVector();\r\n        const raanVector = baseNormal.cross(activeNormal);\r\n        const periapsisVector = keplerianObjectActive.getPeriapsisVector();\r\n\r\n        const inc = baseNormal.angle(activeNormal);\r\n        let raan = raanVector.angle(equinoxVector);\r\n        if (equinoxVector.cross(raanVector).angle(baseNormal) > Math.PI / 2) {\r\n            raan = TWO_PI - raan;\r\n        }\r\n        let aop = raanVector.angle(periapsisVector);\r\n        if (raanVector.cross(periapsisVector).angle(activeNormal) > Math.PI / 2) {\r\n            aop = TWO_PI - aop;\r\n        }\r\n\r\n        const relKeplerianObject = new KeplerianObject(\r\n            keplerianObjectActive.ecc,\r\n            keplerianObjectActive.sma,\r\n            aop,\r\n            inc,\r\n            raan,\r\n            keplerianObjectActive.m0,\r\n            keplerianObjectActive.epoch,\r\n            keplerianObjectActive.mu,\r\n            false\r\n        );\r\n\r\n        return relKeplerianObject.getPlaneCrossingTrueAnomaly(distance);\r\n    }\r\n\r\n    _getRadialTaBounds(keplerianObjectBase, keplerianObjectActive, distance) {\r\n        const r1 = keplerianObjectBase.getPeriapsisRadius() - distance;\r\n        const r2 = keplerianObjectBase.getApoapsisRadius()  + distance;\r\n        const radialTa1 = keplerianObjectActive.getSphereCrossingTrueAnomaly(r1);\r\n        const radialTa2 = keplerianObjectActive.getSphereCrossingTrueAnomaly(r2);\r\n\r\n        if (keplerianObjectBase.isHyperbolic) {\r\n            if (keplerianObjectActive.isHyperbolic) {\r\n                return radialTa1\r\n                    ? [[-Infinity, radialTa1[1] - TWO_PI],[radialTa1[0], Infinity]]\r\n                    : true;\r\n            } else {\r\n                return radialTa1\r\n                    ? [radialTa1]\r\n                    : (keplerianObjectActive.getApoapsisRadius() >= r1);\r\n            }\r\n        }\r\n        // keplerianObjectBase is elliptic\r\n\r\n        if (keplerianObjectActive.isHyperbolic) {\r\n            if (!radialTa2) {\r\n                return false;\r\n            } else if (!radialTa1) {\r\n                return [[radialTa2[1] - TWO_PI, radialTa2[0]]];\r\n            }\r\n            return [\r\n                [radialTa2[1] - TWO_PI, radialTa1[1] - TWO_PI],\r\n                [radialTa1[0], radialTa2[0]],\r\n            ];\r\n        }\r\n        // keplerianObjectActive is elliptic\r\n\r\n        if (radialTa1) {\r\n            return radialTa2\r\n                ? [[radialTa1[0], radialTa2[0]], [radialTa2[1], radialTa1[1]]]\r\n                : [radialTa1];\r\n        } else if (radialTa2) {\r\n            return [[radialTa2[1], radialTa2[0]]];\r\n        }\r\n        return keplerianObjectActive.getPeriapsisRadius() < r2\r\n            && keplerianObjectActive.getApoapsisRadius()  > r1;\r\n    }\r\n\r\n    _createNextSoiTrajectory(originalTrajectory, newSoiBody, epoch) {\r\n        let newReferenceFrame = sim.starSystem.getReferenceFrame(ReferenceFrameFactory.buildId(newSoiBody.id, ReferenceFrame.INERTIAL_ECLIPTIC));\r\n        let newSoiState = newReferenceFrame.stateVectorFromBaseReferenceFrameByEpoch(\r\n            epoch,\r\n            originalTrajectory.getStateByEpoch(epoch)\r\n        );\r\n\r\n        let traj = new TrajectoryKeplerianBasic(\r\n            newReferenceFrame.id,\r\n            KeplerianObject.createFromState(\r\n                newSoiState,\r\n                newSoiBody.physicalModel.mu,\r\n                epoch\r\n            )\r\n        );\r\n        traj.minEpoch = epoch;\r\n        traj.maxEpoch = false;\r\n\r\n        // TODO refactor this\r\n        traj.setVisualModel(new VisualTrajectoryModelKeplerian(\r\n            traj,\r\n            {color: originalTrajectory.visualModel.config.color, minEpoch: false, maxEpoch: 'copy'}\r\n        ));\r\n\r\n        return traj;\r\n    }\r\n\r\n    _createAfterBurnTrajectory(originalTrajectory, impulseVector, epoch) {\r\n        let state = originalTrajectory.getStateInOwnFrameByEpoch(epoch);\r\n        state._velocity.add_(\r\n            Quaternion.twoAxis(state._velocity, null, state._position)\r\n                .rotate_(impulseVector)\r\n        );\r\n\r\n        let traj = new TrajectoryKeplerianBasic(\r\n            originalTrajectory.referenceFrame.id,\r\n            KeplerianObject.createFromState(\r\n                state,\r\n                originalTrajectory.mu,\r\n                epoch\r\n            )\r\n        );\r\n        traj.minEpoch = epoch;\r\n        traj.maxEpoch = false;\r\n\r\n        // TODO refactor this\r\n        traj.setVisualModel(new VisualTrajectoryModelKeplerian(\r\n            traj,\r\n            {color: originalTrajectory.visualModel.config.color, minEpoch: false, maxEpoch: 'copy'}\r\n        ));\r\n\r\n        return traj;\r\n    }\r\n}\r\n"],"sourceRoot":""}