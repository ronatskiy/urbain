{"version":3,"sources":["../static/js/2.e9c219ad.chunk.js","core/Propagator/Abstract.js","modules/PatchedConics/PropagatorPatchedConics.js"],"names":["webpackJsonp","192","module","__webpack_exports__","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","PropagatorAbstract","this","value","trajectory","epochFrom","stopCondition","52","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0__core_Propagator_Abstract__","__WEBPACK_IMPORTED_MODULE_1__core_Trajectory_Composite__","__WEBPACK_IMPORTED_MODULE_2__core_ReferenceFrame_Factory__","__WEBPACK_IMPORTED_MODULE_3__core_Trajectory_KeplerianBasic__","__WEBPACK_IMPORTED_MODULE_4__core_KeplerianObject__","__WEBPACK_IMPORTED_MODULE_5__core_visual_TrajectoryModel_Keplerian__","__WEBPACK_IMPORTED_MODULE_6__core_algebra__","__WEBPACK_IMPORTED_MODULE_7__core_Simulation__","PropagatorPatchedConics","_PropagatorAbstract","_this","getPrototypeOf","soiSafetyCoefficient","maxStep","minStepCount","maxPatchError","Error","epoch","clearAfterEpoch","lastComponent","getComponentByEpoch","Math","max","nextComponent","maxEpoch","_findNextTrajectory","addComponent","epochTo","soi","starSystem","getObject","referenceFrame","originId","ownSoiCrossing","_findOwnSoiCrossing","childSoiCrossing","_findChildSoiCrossing","nextSoiCrossing","_createExtensionTrajectory","newSoi","parent","ko","keplerianObject","sphereCrossing","getSphereCrossingTrueAnomaly","data","patchedConics","soiRadius","getEpochByTrueAnomaly","period","parentSoi","crossings","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","childSois","Symbol","iterator","next","done","childKo","getKeplerianObjectByEpoch","intervals1","_getPotentialApproachIntervals","intervals2","potentialApproachIntervals","sort","i1","i2","crossingFound","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","interval","isFirstStep","step","min","t","prevDistance","distance","getPositionByEpoch","sub_","mag","abs","push","err","return","closestCrossing","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","crossing","keplerianObjectBase","keplerianObjectActive","radialTa","_getRadialTaBounds","verticalTa","_getVerticalTaBounds","taIntervals","inEpoch","outEpoch","adding","isElliptic","floor","maxProcessedEpoch","epochIntervals","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","taInterval","baseNormal","getNormalVector","activeNormal","equinoxVector","getPeriapsisVector","raanVector","cross","periapsisVector","inc","angle","raan","PI","aop","ecc","sma","m0","mu","getPlaneCrossingTrueAnomaly","r1","getPeriapsisRadius","r2","getApoapsisRadius","radialTa1","radialTa2","isHyperbolic","Infinity","originalTrajectory","newSoiBody","newReferenceFrame","getReferenceFrame","buildId","id","INERTIAL_ECLIPTIC","newSoiState","stateVectorFromBaseReferenceFrameByEpoch","getStateByEpoch","traj","createFromState","physicalModel","minEpoch","isEditable","setVisualModel","color","visualModel","standardColor"],"mappings":"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","file":"static/js/2.e9c219ad.chunk.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 192:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}var PropagatorAbstract=function(){function PropagatorAbstract(){_classCallCheck(this,PropagatorAbstract);}_createClass(PropagatorAbstract,[{key:\"propagate\",value:function propagate(trajectory,epochFrom,stopCondition){}}]);return PropagatorAbstract;}();/* harmony default export */ __webpack_exports__[\"a\"] = (PropagatorAbstract);\n\n/***/ }),\n\n/***/ 52:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Propagator_Abstract__ = __webpack_require__(192);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Trajectory_Composite__ = __webpack_require__(25);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_ReferenceFrame_Factory__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_Trajectory_KeplerianBasic__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_KeplerianObject__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_visual_TrajectoryModel_Keplerian__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_algebra__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__core_Simulation__ = __webpack_require__(1);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}// import VisualPoint from \"../../visual/Point\";\n// import Constant from \"../../core/FunctionOfEpoch/Constant\";\nvar PropagatorPatchedConics=function(_PropagatorAbstract){_inherits(PropagatorPatchedConics,_PropagatorAbstract);function PropagatorPatchedConics(){_classCallCheck(this,PropagatorPatchedConics);var _this=_possibleConstructorReturn(this,(PropagatorPatchedConics.__proto__||Object.getPrototypeOf(PropagatorPatchedConics)).call(this));_this.soiSafetyCoefficient=1.5;_this.maxStep=3600;_this.minStepCount=100;_this.maxPatchError=1e-3;// 1 meter\n// this.debugPoints = [];\nreturn _this;}_createClass(PropagatorPatchedConics,[{key:\"propagate\",value:function propagate(trajectory,epochFrom,stopCondition){if(!trajectory instanceof __WEBPACK_IMPORTED_MODULE_1__core_Trajectory_Composite__[\"a\" /* default */]){throw new Error('Patched conics propagation requires TrajectoryComposite instance');}if(!stopCondition.epoch){throw new Error('Patched conics propagation requires epoch in stop condition');}trajectory.clearAfterEpoch(epochFrom);var lastComponent=trajectory.getComponentByEpoch(epochFrom);var epoch=Math.max(epochFrom,lastComponent.epoch);var nextComponent=void 0;lastComponent.maxEpoch=false;/*\r\n        for (let point of this.debugPoints) {\r\n            point.drop();\r\n        }\r\n        this.debugPoints = [];\r\n*/// console.log('Propagating...');\ndo{// console.log('Looking for next component...');\nnextComponent=this._findNextTrajectory(lastComponent,epoch,stopCondition.epoch);if(nextComponent){// console.log('Component found', nextComponent);\ntrajectory.addComponent(nextComponent);epoch=nextComponent.epoch;lastComponent.maxEpoch=epoch;lastComponent=nextComponent;}}while(nextComponent&&epoch<stopCondition.epoch);}},{key:\"_findNextTrajectory\",value:function _findNextTrajectory(trajectory,epochFrom,epochTo){var soi=__WEBPACK_IMPORTED_MODULE_7__core_Simulation__[\"a\" /* sim */].starSystem.getObject(trajectory.referenceFrame.originId);var ownSoiCrossing=this._findOwnSoiCrossing(soi,trajectory,epochFrom);var childSoiCrossing=this._findChildSoiCrossing(soi,trajectory,epochFrom,epochTo);if(childSoiCrossing===false&&ownSoiCrossing===false){return false;}var nextSoiCrossing=!childSoiCrossing||ownSoiCrossing&&ownSoiCrossing.epoch<childSoiCrossing.epoch?ownSoiCrossing:childSoiCrossing;return this._createExtensionTrajectory(trajectory,nextSoiCrossing.newSoi,nextSoiCrossing.epoch);}},{key:\"_findOwnSoiCrossing\",value:function _findOwnSoiCrossing(parent,trajectory,epochFrom){var ko=trajectory.keplerianObject;var sphereCrossing=ko.getSphereCrossingTrueAnomaly(parent.data.patchedConics.soiRadius);if(!sphereCrossing){return false;}var epoch=ko.getEpochByTrueAnomaly(sphereCrossing[0]);while(epoch<epochFrom){epoch+=ko.period;}return{epoch:epoch,newSoi:parent.data.patchedConics.parentSoi};}},{key:\"_findChildSoiCrossing\",value:function _findChildSoiCrossing(parent,trajectory,epochFrom,epochTo){var ko=trajectory.keplerianObject;var crossings=[];var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=parent.data.patchedConics.childSois[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var soi=_step.value;var childKo=soi.trajectory.getKeplerianObjectByEpoch(epochFrom,trajectory.referenceFrame);var soiRadius=soi.data.patchedConics.soiRadius;var intervals1=this._getPotentialApproachIntervals(childKo,ko,epochFrom,epochTo,soiRadius*this.soiSafetyCoefficient);if(intervals1===false){continue;}var intervals2=this._getPotentialApproachIntervals(ko,childKo,epochFrom,epochTo,soiRadius*this.soiSafetyCoefficient);/*\r\n            if (this.debugPoints.length === 0) {\r\n                if (intervals1 && intervals1 instanceof Array)\r\n                    for (let interval of intervals1) {\r\n                        this.debugPoints.push(new VisualPoint(new Constant(trajectory.getPositionByEpoch(interval[0], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'blue', 6));\r\n                        this.debugPoints.push(new VisualPoint(new Constant(trajectory.getPositionByEpoch(interval[1], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'blue', 10));\r\n                    }\r\n\r\n                if (intervals2 && intervals2 instanceof Array)\r\n                    for (let interval of intervals2) {\r\n                        this.debugPoints.push(new VisualPoint(new Constant(soi.trajectory.getPositionByEpoch(interval[0], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'yellow', 6));\r\n                        this.debugPoints.push(new VisualPoint(new Constant(soi.trajectory.getPositionByEpoch(interval[1], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'yellow', 10));\r\n                    }\r\n            }\r\n*/var potentialApproachIntervals=Object(__WEBPACK_IMPORTED_MODULE_6__core_algebra__[\"i\" /* getEpochIntervalsIntersection */])(intervals1,intervals2);if(potentialApproachIntervals===false){continue;}if(potentialApproachIntervals===true){// TODO optimize this case\npotentialApproachIntervals=[[epochFrom,epochTo]];}potentialApproachIntervals.sort(function(i1,i2){return i1[0]<i2[0]?-1:i1[0]>i2[0]?1:0;});var crossingFound=false;// console.log('Iterating...');\nvar _iteratorNormalCompletion3=true;var _didIteratorError3=false;var _iteratorError3=undefined;try{for(var _iterator3=potentialApproachIntervals[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){var interval=_step3.value;if(interval[0]>epochTo){break;}if(interval[1]<epochFrom){continue;}if(interval[0]<epochFrom){interval[0]=epochFrom;}if(interval[1]>epochTo){interval[1]=epochTo;}var isFirstStep=true;var step=Math.min(this.maxStep,(interval[1]-interval[0])/this.minStepCount);var t=interval[0];var prevDistance=0;// console.log('Iterating interval...', interval[1] - interval[0], step);\nwhile(t<interval[1]){var distance=trajectory.getPositionByEpoch(t).sub_(soi.getPositionByEpoch(t)).mag-soiRadius;// console.log('T Distance', t, distance);\nif(distance<0){// found a point in time when we are inside SOI\n// console.log('Found');\nif(isFirstStep){// console.log('Iterating forward');\ndo{t+=step;if(t>interval[1]){t=interval[1];}distance=trajectory.getPositionByEpoch(t).sub_(soi.getPositionByEpoch(t)).mag-soiRadius;}while(distance<0&&t<interval[1]);// console.log('Distance', distance);\nif(distance<0){break;}continue;}// console.log('Looking for boundary');\nwhile(Math.abs(distance)>this.maxPatchError){// looking for SOI crossing time now\nstep*=distance/(prevDistance-distance);t+=step;prevDistance=distance;distance=trajectory.getPositionByEpoch(t).sub_(soi.getPositionByEpoch(t)).mag-soiRadius;// console.log('T Step distance', t, step, distance);\n}// console.log('Boundary found', t);\ncrossings.push({epoch:t,newSoi:soi});crossingFound=true;break;}prevDistance=distance;isFirstStep=false;t+=step;}if(crossingFound){break;}// console.log('Crossing not found');\n}}catch(err){_didIteratorError3=true;_iteratorError3=err;}finally{try{if(!_iteratorNormalCompletion3&&_iterator3.return){_iterator3.return();}}finally{if(_didIteratorError3){throw _iteratorError3;}}}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator.return){_iterator.return();}}finally{if(_didIteratorError){throw _iteratorError;}}}if(!crossings.length){return false;}var closestCrossing=crossings[0];var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator2=crossings[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){var crossing=_step2.value;if(crossing.epoch<closestCrossing.epoch){closestCrossing=crossing;}}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally{try{if(!_iteratorNormalCompletion2&&_iterator2.return){_iterator2.return();}}finally{if(_didIteratorError2){throw _iteratorError2;}}}return closestCrossing;}},{key:\"_getPotentialApproachIntervals\",value:function _getPotentialApproachIntervals(keplerianObjectBase,keplerianObjectActive,epochFrom,epochTo,distance){var radialTa=this._getRadialTaBounds(keplerianObjectBase,keplerianObjectActive,distance);if(radialTa===false){return false;}var verticalTa=this._getVerticalTaBounds(keplerianObjectBase,keplerianObjectActive,epochFrom,distance);var taIntervals=void 0;if(verticalTa){taIntervals=Object(__WEBPACK_IMPORTED_MODULE_6__core_algebra__[\"h\" /* getAngleIntervalsIntersection */])(verticalTa,radialTa);}else{if(radialTa===true){return true;}else{taIntervals=radialTa;}}if(taIntervals===false){return false;}var period=keplerianObjectActive.period;var inEpoch=void 0,outEpoch=void 0;var adding=keplerianObjectActive.isElliptic?Math.floor((epochFrom-keplerianObjectActive.epoch)/period)*period:0;var maxProcessedEpoch=0;var epochIntervals=[];do{var _iteratorNormalCompletion4=true;var _didIteratorError4=false;var _iteratorError4=undefined;try{for(var _iterator4=taIntervals[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=true){var taInterval=_step4.value;inEpoch=keplerianObjectActive.getEpochByTrueAnomaly(taInterval[0])+adding;outEpoch=keplerianObjectActive.getEpochByTrueAnomaly(taInterval[1])+adding;if(outEpoch<inEpoch){inEpoch-=period;}if(outEpoch>maxProcessedEpoch){maxProcessedEpoch=outEpoch;}if(outEpoch<epochFrom){continue;}if(epochIntervals.length>10000){debugger;throw new Error('Infinite loop detected');}epochIntervals.push([inEpoch,outEpoch]);}}catch(err){_didIteratorError4=true;_iteratorError4=err;}finally{try{if(!_iteratorNormalCompletion4&&_iterator4.return){_iterator4.return();}}finally{if(_didIteratorError4){throw _iteratorError4;}}}adding+=period;}while(maxProcessedEpoch<epochTo&&keplerianObjectActive.isElliptic);return epochIntervals;}},{key:\"_getVerticalTaBounds\",value:function _getVerticalTaBounds(keplerianObjectBase,keplerianObjectActive,epochFrom,distance){// this is only to recalculate inc, raan and aop. probably can be optimized.\nvar baseNormal=keplerianObjectBase.getNormalVector();var activeNormal=keplerianObjectActive.getNormalVector();var equinoxVector=keplerianObjectBase.getPeriapsisVector();var raanVector=baseNormal.cross(activeNormal);var periapsisVector=keplerianObjectActive.getPeriapsisVector();var inc=baseNormal.angle(activeNormal);var raan=raanVector.angle(equinoxVector);if(equinoxVector.cross(raanVector).angle(baseNormal)>Math.PI/2){raan=__WEBPACK_IMPORTED_MODULE_6__core_algebra__[\"b\" /* TWO_PI */]-raan;}var aop=raanVector.angle(periapsisVector);if(raanVector.cross(periapsisVector).angle(activeNormal)>Math.PI/2){aop=__WEBPACK_IMPORTED_MODULE_6__core_algebra__[\"b\" /* TWO_PI */]-aop;}var relKeplerianObject=new __WEBPACK_IMPORTED_MODULE_4__core_KeplerianObject__[\"a\" /* default */](keplerianObjectActive.ecc,keplerianObjectActive.sma,aop,inc,raan,keplerianObjectActive.m0,keplerianObjectActive.epoch,keplerianObjectActive.mu,false);return relKeplerianObject.getPlaneCrossingTrueAnomaly(distance);}},{key:\"_getRadialTaBounds\",value:function _getRadialTaBounds(keplerianObjectBase,keplerianObjectActive,distance){var r1=keplerianObjectBase.getPeriapsisRadius()-distance;var r2=keplerianObjectBase.getApoapsisRadius()+distance;var radialTa1=keplerianObjectActive.getSphereCrossingTrueAnomaly(r1);var radialTa2=keplerianObjectActive.getSphereCrossingTrueAnomaly(r2);if(keplerianObjectBase.isHyperbolic){if(keplerianObjectActive.isHyperbolic){return radialTa1?[[-Infinity,radialTa1[1]-__WEBPACK_IMPORTED_MODULE_6__core_algebra__[\"b\" /* TWO_PI */]],[radialTa1[0],Infinity]]:true;}else{return radialTa1?[radialTa1]:keplerianObjectActive.getApoapsisRadius()>=r1;}}// keplerianObjectBase is elliptic\nif(keplerianObjectActive.isHyperbolic){if(!radialTa2){return false;}else if(!radialTa1){return[[radialTa2[1]-__WEBPACK_IMPORTED_MODULE_6__core_algebra__[\"b\" /* TWO_PI */],radialTa2[0]]];}return[[radialTa2[1]-__WEBPACK_IMPORTED_MODULE_6__core_algebra__[\"b\" /* TWO_PI */],radialTa1[1]-__WEBPACK_IMPORTED_MODULE_6__core_algebra__[\"b\" /* TWO_PI */]],[radialTa1[0],radialTa2[0]]];}// keplerianObjectActive is elliptic\nif(radialTa1){return radialTa2?[[radialTa1[0],radialTa2[0]],[radialTa2[1],radialTa1[1]]]:[radialTa1];}else if(radialTa2){return[[radialTa2[1],radialTa2[0]]];}return keplerianObjectActive.getPeriapsisRadius()<r2&&keplerianObjectActive.getApoapsisRadius()>r1;}},{key:\"_createExtensionTrajectory\",value:function _createExtensionTrajectory(originalTrajectory,newSoiBody,epoch){var newReferenceFrame=__WEBPACK_IMPORTED_MODULE_7__core_Simulation__[\"a\" /* sim */].starSystem.getReferenceFrame(__WEBPACK_IMPORTED_MODULE_2__core_ReferenceFrame_Factory__[\"d\" /* default */].buildId(newSoiBody.id,__WEBPACK_IMPORTED_MODULE_2__core_ReferenceFrame_Factory__[\"c\" /* ReferenceFrame */].INERTIAL_ECLIPTIC));var newSoiState=newReferenceFrame.stateVectorFromBaseReferenceFrameByEpoch(epoch,originalTrajectory.getStateByEpoch(epoch));var traj=new __WEBPACK_IMPORTED_MODULE_3__core_Trajectory_KeplerianBasic__[\"a\" /* default */](newReferenceFrame.id,__WEBPACK_IMPORTED_MODULE_4__core_KeplerianObject__[\"a\" /* default */].createFromState(newSoiState,newSoiBody.physicalModel.mu,epoch));traj.minEpoch=epoch;traj.maxEpoch=false;traj.isEditable=false;// TODO refactor this\ntraj.setVisualModel(new __WEBPACK_IMPORTED_MODULE_5__core_visual_TrajectoryModel_Keplerian__[\"a\" /* default */](traj,{color:originalTrajectory.visualModel.standardColor,minEpoch:null,maxEpoch:null}));return traj;}}]);return PropagatorPatchedConics;}(__WEBPACK_IMPORTED_MODULE_0__core_Propagator_Abstract__[\"a\" /* default */]);/* harmony default export */ __webpack_exports__[\"default\"] = (PropagatorPatchedConics);\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/2.e9c219ad.chunk.js","export default class PropagatorAbstract\r\n{\r\n    propagate(trajectory, epochFrom, stopCondition) {}\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/core/Propagator/Abstract.js","import PropagatorAbstract from \"../../core/Propagator/Abstract\";\r\nimport TrajectoryComposite from \"../../core/Trajectory/Composite\";\r\nimport ReferenceFrameFactory, {ReferenceFrame} from \"../../core/ReferenceFrame/Factory\";\r\nimport TrajectoryKeplerianBasic from \"../../core/Trajectory/KeplerianBasic\";\r\nimport KeplerianObject from \"../../core/KeplerianObject\";\r\nimport VisualTrajectoryModelKeplerian from \"../../core/visual/TrajectoryModel/Keplerian\";\r\nimport {getAngleIntervalsIntersection, getEpochIntervalsIntersection, TWO_PI} from \"../../core/algebra\";\r\nimport { sim } from \"../../core/Simulation\";\r\n// import VisualPoint from \"../../visual/Point\";\r\n// import Constant from \"../../core/FunctionOfEpoch/Constant\";\r\n\r\nexport default class PropagatorPatchedConics extends PropagatorAbstract\r\n{\r\n    constructor() {\r\n        super();\r\n        this.soiSafetyCoefficient = 1.5;\r\n        this.maxStep = 3600;\r\n        this.minStepCount = 100;\r\n        this.maxPatchError = 1e-3; // 1 meter\r\n        // this.debugPoints = [];\r\n    }\r\n\r\n    propagate(trajectory, epochFrom, stopCondition) {\r\n        if (!trajectory instanceof TrajectoryComposite) {\r\n            throw new Error('Patched conics propagation requires TrajectoryComposite instance');\r\n        }\r\n        if (!stopCondition.epoch) {\r\n            throw new Error('Patched conics propagation requires epoch in stop condition');\r\n        }\r\n\r\n        trajectory.clearAfterEpoch(epochFrom);\r\n\r\n        let lastComponent = trajectory.getComponentByEpoch(epochFrom);\r\n        let epoch = Math.max(epochFrom, lastComponent.epoch);\r\n        let nextComponent;\r\n\r\n        lastComponent.maxEpoch = false;\r\n/*\r\n        for (let point of this.debugPoints) {\r\n            point.drop();\r\n        }\r\n        this.debugPoints = [];\r\n*/\r\n        // console.log('Propagating...');\r\n\r\n        do {\r\n            // console.log('Looking for next component...');\r\n            nextComponent = this._findNextTrajectory(lastComponent, epoch, stopCondition.epoch);\r\n            if (nextComponent) {\r\n                // console.log('Component found', nextComponent);\r\n                trajectory.addComponent(nextComponent);\r\n                epoch = nextComponent.epoch;\r\n                lastComponent.maxEpoch = epoch;\r\n                lastComponent = nextComponent;\r\n            }\r\n        } while (nextComponent && epoch < stopCondition.epoch);\r\n    }\r\n\r\n    _findNextTrajectory(trajectory, epochFrom, epochTo) {\r\n        const soi = sim.starSystem.getObject(trajectory.referenceFrame.originId);\r\n        const ownSoiCrossing   = this._findOwnSoiCrossing  (soi, trajectory, epochFrom);\r\n        const childSoiCrossing = this._findChildSoiCrossing(soi, trajectory, epochFrom, epochTo);\r\n\r\n        if (childSoiCrossing === false && ownSoiCrossing === false) {\r\n            return false;\r\n        }\r\n\r\n        let nextSoiCrossing = (!childSoiCrossing || (ownSoiCrossing && ownSoiCrossing.epoch < childSoiCrossing.epoch))\r\n            ? ownSoiCrossing\r\n            : childSoiCrossing;\r\n\r\n        return this._createExtensionTrajectory(trajectory, nextSoiCrossing.newSoi, nextSoiCrossing.epoch);\r\n    }\r\n\r\n    _findOwnSoiCrossing(parent, trajectory, epochFrom) {\r\n        const ko = trajectory.keplerianObject;\r\n        const sphereCrossing = ko.getSphereCrossingTrueAnomaly(parent.data.patchedConics.soiRadius);\r\n\r\n        if (!sphereCrossing) {\r\n            return false;\r\n        }\r\n\r\n        let epoch = ko.getEpochByTrueAnomaly(sphereCrossing[0]);\r\n        while (epoch < epochFrom) {\r\n            epoch += ko.period;\r\n        }\r\n\r\n        return {\r\n            epoch: epoch,\r\n            newSoi: parent.data.patchedConics.parentSoi\r\n        };\r\n    }\r\n\r\n    _findChildSoiCrossing(parent, trajectory, epochFrom, epochTo) {\r\n        const ko = trajectory.keplerianObject;\r\n        let crossings = [];\r\n\r\n        for (let soi of parent.data.patchedConics.childSois) {\r\n            const childKo = soi.trajectory.getKeplerianObjectByEpoch(epochFrom, trajectory.referenceFrame);\r\n            const soiRadius = soi.data.patchedConics.soiRadius;\r\n            const intervals1 = this._getPotentialApproachIntervals(childKo, ko, epochFrom, epochTo, soiRadius * this.soiSafetyCoefficient);\r\n            if (intervals1 === false) {\r\n                continue;\r\n            }\r\n\r\n            const intervals2 = this._getPotentialApproachIntervals(ko, childKo, epochFrom, epochTo, soiRadius * this.soiSafetyCoefficient);\r\n/*\r\n            if (this.debugPoints.length === 0) {\r\n                if (intervals1 && intervals1 instanceof Array)\r\n                    for (let interval of intervals1) {\r\n                        this.debugPoints.push(new VisualPoint(new Constant(trajectory.getPositionByEpoch(interval[0], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'blue', 6));\r\n                        this.debugPoints.push(new VisualPoint(new Constant(trajectory.getPositionByEpoch(interval[1], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'blue', 10));\r\n                    }\r\n\r\n                if (intervals2 && intervals2 instanceof Array)\r\n                    for (let interval of intervals2) {\r\n                        this.debugPoints.push(new VisualPoint(new Constant(soi.trajectory.getPositionByEpoch(interval[0], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'yellow', 6));\r\n                        this.debugPoints.push(new VisualPoint(new Constant(soi.trajectory.getPositionByEpoch(interval[1], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'yellow', 10));\r\n                    }\r\n            }\r\n*/\r\n            let potentialApproachIntervals = getEpochIntervalsIntersection(intervals1, intervals2);\r\n\r\n            if (potentialApproachIntervals === false) {\r\n                continue;\r\n            }\r\n            if (potentialApproachIntervals === true) {\r\n                // TODO optimize this case\r\n                potentialApproachIntervals = [[epochFrom, epochTo]];\r\n            }\r\n\r\n            potentialApproachIntervals.sort((i1, i2) => (i1[0] < i2[0]) ? -1 : (i1[0] > i2[0] ? 1 : 0));\r\n\r\n            let crossingFound = false;\r\n            // console.log('Iterating...');\r\n            for (let interval of potentialApproachIntervals) {\r\n                if (interval[0] > epochTo) {\r\n                    break;\r\n                }\r\n                if (interval[1] < epochFrom) {\r\n                    continue;\r\n                }\r\n                if (interval[0] < epochFrom) {\r\n                    interval[0] = epochFrom;\r\n                }\r\n                if (interval[1] > epochTo) {\r\n                    interval[1] = epochTo;\r\n                }\r\n                let isFirstStep = true;\r\n                let step = Math.min(this.maxStep, (interval[1] - interval[0]) / this.minStepCount);\r\n                let t = interval[0];\r\n                let prevDistance = 0;\r\n                // console.log('Iterating interval...', interval[1] - interval[0], step);\r\n                while (t < interval[1]) {\r\n                    let distance = trajectory.getPositionByEpoch(t).sub_(soi.getPositionByEpoch(t)).mag - soiRadius;\r\n                    // console.log('T Distance', t, distance);\r\n                    if (distance < 0) { // found a point in time when we are inside SOI\r\n                        // console.log('Found');\r\n                        if (isFirstStep) {\r\n                            // console.log('Iterating forward');\r\n                            do {\r\n                                t += step;\r\n                                if (t > interval[1]) {\r\n                                    t = interval[1];\r\n                                }\r\n                                distance = trajectory.getPositionByEpoch(t).sub_(soi.getPositionByEpoch(t)).mag - soiRadius;\r\n                            } while (distance < 0 && t < interval[1]);\r\n                            // console.log('Distance', distance);\r\n                            if (distance < 0) {\r\n                                break;\r\n                            }\r\n                            continue;\r\n                        }\r\n                        // console.log('Looking for boundary');\r\n                        while (Math.abs(distance) > this.maxPatchError) { // looking for SOI crossing time now\r\n                            step *= distance / (prevDistance - distance);\r\n                            t += step;\r\n                            prevDistance = distance;\r\n                            distance = trajectory.getPositionByEpoch(t).sub_(soi.getPositionByEpoch(t)).mag - soiRadius;\r\n                            // console.log('T Step distance', t, step, distance);\r\n                        }\r\n                        // console.log('Boundary found', t);\r\n                        crossings.push({\r\n                            epoch: t,\r\n                            newSoi: soi\r\n                        });\r\n                        crossingFound = true;\r\n                        break;\r\n                    }\r\n                    prevDistance = distance;\r\n                    isFirstStep = false;\r\n                    t += step;\r\n                }\r\n\r\n                if (crossingFound) {\r\n                    break;\r\n                }\r\n                // console.log('Crossing not found');\r\n            }\r\n        }\r\n\r\n        if (!crossings.length) {\r\n            return false;\r\n        }\r\n\r\n        let closestCrossing = crossings[0];\r\n        for (let crossing of crossings) {\r\n            if (crossing.epoch < closestCrossing.epoch) {\r\n                closestCrossing = crossing;\r\n            }\r\n        }\r\n\r\n        return closestCrossing;\r\n    }\r\n\r\n    _getPotentialApproachIntervals(keplerianObjectBase, keplerianObjectActive, epochFrom, epochTo, distance) {\r\n        const radialTa = this._getRadialTaBounds(keplerianObjectBase, keplerianObjectActive, distance);\r\n        if (radialTa === false) {\r\n            return false;\r\n        }\r\n\r\n        const verticalTa = this._getVerticalTaBounds(keplerianObjectBase, keplerianObjectActive, epochFrom, distance);\r\n        let taIntervals;\r\n\r\n        if (verticalTa) {\r\n            taIntervals = getAngleIntervalsIntersection(verticalTa, radialTa);\r\n        } else {\r\n            if (radialTa === true) {\r\n                return true;\r\n            } else {\r\n                taIntervals = radialTa;\r\n            }\r\n        }\r\n\r\n        if (taIntervals === false) {\r\n            return false;\r\n        }\r\n\r\n        const period = keplerianObjectActive.period;\r\n        let inEpoch, outEpoch;\r\n        let adding = keplerianObjectActive.isElliptic\r\n            ? Math.floor((epochFrom - keplerianObjectActive.epoch) / period) * period\r\n            : 0;\r\n        let maxProcessedEpoch = 0;\r\n        let epochIntervals = [];\r\n\r\n        do {\r\n            for (let taInterval of taIntervals) {\r\n                inEpoch = keplerianObjectActive.getEpochByTrueAnomaly(taInterval[0]) + adding;\r\n                outEpoch = keplerianObjectActive.getEpochByTrueAnomaly(taInterval[1]) + adding;\r\n\r\n                if (outEpoch < inEpoch) {\r\n                    inEpoch -= period;\r\n                }\r\n\r\n                if (outEpoch > maxProcessedEpoch) {\r\n                    maxProcessedEpoch = outEpoch;\r\n                }\r\n                if (outEpoch < epochFrom) {\r\n                    continue;\r\n                }\r\n\r\n                if (epochIntervals.length > 10000) {\r\n                    debugger;\r\n                    throw new Error('Infinite loop detected');\r\n                }\r\n\r\n                epochIntervals.push([inEpoch, outEpoch]);\r\n            }\r\n            adding += period;\r\n\r\n        } while (maxProcessedEpoch < epochTo && keplerianObjectActive.isElliptic);\r\n\r\n        return epochIntervals;\r\n    }\r\n\r\n    _getVerticalTaBounds(keplerianObjectBase, keplerianObjectActive, epochFrom, distance) {\r\n        // this is only to recalculate inc, raan and aop. probably can be optimized.\r\n        const baseNormal = keplerianObjectBase.getNormalVector();\r\n        const activeNormal = keplerianObjectActive.getNormalVector();\r\n        const equinoxVector = keplerianObjectBase.getPeriapsisVector();\r\n        const raanVector = baseNormal.cross(activeNormal);\r\n        const periapsisVector = keplerianObjectActive.getPeriapsisVector();\r\n\r\n        const inc = baseNormal.angle(activeNormal);\r\n        let raan = raanVector.angle(equinoxVector);\r\n        if (equinoxVector.cross(raanVector).angle(baseNormal) > Math.PI / 2) {\r\n            raan = TWO_PI - raan;\r\n        }\r\n        let aop = raanVector.angle(periapsisVector);\r\n        if (raanVector.cross(periapsisVector).angle(activeNormal) > Math.PI / 2) {\r\n            aop = TWO_PI - aop;\r\n        }\r\n\r\n        const relKeplerianObject = new KeplerianObject(\r\n            keplerianObjectActive.ecc,\r\n            keplerianObjectActive.sma,\r\n            aop,\r\n            inc,\r\n            raan,\r\n            keplerianObjectActive.m0,\r\n            keplerianObjectActive.epoch,\r\n            keplerianObjectActive.mu,\r\n            false\r\n        );\r\n\r\n        return relKeplerianObject.getPlaneCrossingTrueAnomaly(distance);\r\n    }\r\n\r\n    _getRadialTaBounds(keplerianObjectBase, keplerianObjectActive, distance) {\r\n        const r1 = keplerianObjectBase.getPeriapsisRadius() - distance;\r\n        const r2 = keplerianObjectBase.getApoapsisRadius()  + distance;\r\n        const radialTa1 = keplerianObjectActive.getSphereCrossingTrueAnomaly(r1);\r\n        const radialTa2 = keplerianObjectActive.getSphereCrossingTrueAnomaly(r2);\r\n\r\n        if (keplerianObjectBase.isHyperbolic) {\r\n            if (keplerianObjectActive.isHyperbolic) {\r\n                return radialTa1\r\n                    ? [[-Infinity, radialTa1[1] - TWO_PI],[radialTa1[0], Infinity]]\r\n                    : true;\r\n            } else {\r\n                return radialTa1\r\n                    ? [radialTa1]\r\n                    : (keplerianObjectActive.getApoapsisRadius() >= r1);\r\n            }\r\n        }\r\n        // keplerianObjectBase is elliptic\r\n\r\n        if (keplerianObjectActive.isHyperbolic) {\r\n            if (!radialTa2) {\r\n                return false;\r\n            } else if (!radialTa1) {\r\n                return [[radialTa2[1] - TWO_PI, radialTa2[0]]];\r\n            }\r\n            return [\r\n                [radialTa2[1] - TWO_PI, radialTa1[1] - TWO_PI],\r\n                [radialTa1[0], radialTa2[0]],\r\n            ];\r\n        }\r\n        // keplerianObjectActive is elliptic\r\n\r\n        if (radialTa1) {\r\n            return radialTa2\r\n                ? [[radialTa1[0], radialTa2[0]], [radialTa2[1], radialTa1[1]]]\r\n                : [radialTa1];\r\n        } else if (radialTa2) {\r\n            return [[radialTa2[1], radialTa2[0]]];\r\n        }\r\n        return keplerianObjectActive.getPeriapsisRadius() < r2\r\n            && keplerianObjectActive.getApoapsisRadius()  > r1;\r\n    }\r\n\r\n    _createExtensionTrajectory(originalTrajectory, newSoiBody, epoch) {\r\n        let newReferenceFrame = sim.starSystem.getReferenceFrame(ReferenceFrameFactory.buildId(newSoiBody.id, ReferenceFrame.INERTIAL_ECLIPTIC));\r\n        let newSoiState = newReferenceFrame.stateVectorFromBaseReferenceFrameByEpoch(\r\n            epoch,\r\n            originalTrajectory.getStateByEpoch(epoch)\r\n        );\r\n\r\n        let traj = new TrajectoryKeplerianBasic(\r\n            newReferenceFrame.id,\r\n            KeplerianObject.createFromState(\r\n                newSoiState,\r\n                newSoiBody.physicalModel.mu,\r\n                epoch\r\n            )\r\n        );\r\n        traj.minEpoch = epoch;\r\n        traj.maxEpoch = false;\r\n        traj.isEditable = false;\r\n\r\n        // TODO refactor this\r\n        traj.setVisualModel(new VisualTrajectoryModelKeplerian(\r\n            traj,\r\n            {color: originalTrajectory.visualModel.standardColor, minEpoch: null, maxEpoch: null}\r\n        ));\r\n\r\n        return traj;\r\n    }\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/modules/PatchedConics/PropagatorPatchedConics.js"],"sourceRoot":""}