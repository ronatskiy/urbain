{"version":3,"sources":["core/Propagator/Abstract.js","modules/PatchedConics/PropagatorPatchedConics.js"],"names":["PropagatorAbstract","trajectory","epochFrom","stopCondition","PropagatorPatchedConics","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","soiSafetyCoefficient","maxStep","minStepCount","maxPatchError","TrajectoryComposite","Error","epoch","clearAfterEpoch","nextComponent","lastComponent","getComponentByEpoch","Math","max","maxEpoch","_findNextTrajectory","addComponent","epochTo","soi","sim","starSystem","getObject","referenceFrame","originId","ownSoiCrossing","_findOwnSoiCrossing","childSoiCrossing","_findChildSoiCrossing","nextSoiCrossing","_createExtensionTrajectory","newSoi","parent","ko","keplerianObject","sphereCrossing","getSphereCrossingTrueAnomaly","data","patchedConics","soiRadius","getEpochByTrueAnomaly","period","parentSoi","crossings","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","childSois","Symbol","iterator","next","done","value","childKo","getKeplerianObjectByEpoch","intervals1","_getPotentialApproachIntervals","intervals2","potentialApproachIntervals","getEpochIntervalsIntersection","sort","i1","i2","crossingFound","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","interval","isFirstStep","step","min","t","prevDistance","distance","getPositionByEpoch","sub_","mag","abs","push","err","return","length","closestCrossing","_i","crossing","keplerianObjectBase","keplerianObjectActive","radialTa","_getRadialTaBounds","taIntervals","verticalTa","_getVerticalTaBounds","getAngleIntervalsIntersection","inEpoch","outEpoch","adding","isElliptic","floor","maxProcessedEpoch","epochIntervals","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","taInterval","baseNormal","getNormalVector","activeNormal","equinoxVector","getPeriapsisVector","raanVector","cross","periapsisVector","inc","angle","raan","PI","TWO_PI","aop","KeplerianObject","ecc","sma","m0","mu","getPlaneCrossingTrueAnomaly","r1","getPeriapsisRadius","r2","getApoapsisRadius","radialTa1","radialTa2","isHyperbolic","Infinity","originalTrajectory","newSoiBody","newReferenceFrame","getReferenceFrame","ReferenceFrameFactory","buildId","id","ReferenceFrame","INERTIAL_ECLIPTIC","newSoiState","stateVectorFromBaseReferenceFrameByEpoch","getStateByEpoch","traj","TrajectoryKeplerianBasic","createFromState","physicalModel","minEpoch","isEditable","setVisualModel","VisualTrajectoryModelKeplerian","color","visualModel","standardColor"],"mappings":"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","file":"static/js/3.ed2fd60c.chunk.js","sourcesContent":["export default class PropagatorAbstract\r\n{\r\n    propagate(trajectory, epochFrom, stopCondition) {}\r\n}","import PropagatorAbstract from \"../../core/Propagator/Abstract\";\r\nimport TrajectoryComposite from \"../../core/Trajectory/Composite\";\r\nimport ReferenceFrameFactory, {ReferenceFrame} from \"../../core/ReferenceFrame/Factory\";\r\nimport TrajectoryKeplerianBasic from \"../../core/Trajectory/KeplerianBasic\";\r\nimport KeplerianObject from \"../../core/KeplerianObject\";\r\nimport VisualTrajectoryModelKeplerian from \"../../core/visual/TrajectoryModel/Keplerian\";\r\nimport {getAngleIntervalsIntersection, getEpochIntervalsIntersection, TWO_PI} from \"../../core/algebra\";\r\nimport { sim } from \"../../core/Simulation\";\r\n// import VisualPoint from \"../../visual/Point\";\r\n// import Constant from \"../../core/FunctionOfEpoch/Constant\";\r\n\r\nexport default class PropagatorPatchedConics extends PropagatorAbstract\r\n{\r\n    constructor() {\r\n        super();\r\n        this.soiSafetyCoefficient = 1.5;\r\n        this.maxStep = 3600;\r\n        this.minStepCount = 100;\r\n        this.maxPatchError = 1e-3; // 1 meter\r\n        // this.debugPoints = [];\r\n    }\r\n\r\n    propagate(trajectory, epochFrom, stopCondition) {\r\n        if (!trajectory instanceof TrajectoryComposite) {\r\n            throw new Error('Patched conics propagation requires TrajectoryComposite instance');\r\n        }\r\n        if (!stopCondition.epoch) {\r\n            throw new Error('Patched conics propagation requires epoch in stop condition');\r\n        }\r\n\r\n        trajectory.clearAfterEpoch(epochFrom);\r\n\r\n        let lastComponent = trajectory.getComponentByEpoch(epochFrom);\r\n        let epoch = Math.max(epochFrom, lastComponent.epoch);\r\n        let nextComponent;\r\n\r\n        lastComponent.maxEpoch = false;\r\n/*\r\n        for (let point of this.debugPoints) {\r\n            point.drop();\r\n        }\r\n        this.debugPoints = [];\r\n*/\r\n        // console.log('Propagating...');\r\n\r\n        do {\r\n            // console.log('Looking for next component...');\r\n            nextComponent = this._findNextTrajectory(lastComponent, epoch, stopCondition.epoch);\r\n            if (nextComponent) {\r\n                // console.log('Component found', nextComponent);\r\n                trajectory.addComponent(nextComponent);\r\n                epoch = nextComponent.epoch;\r\n                lastComponent.maxEpoch = epoch;\r\n                lastComponent = nextComponent;\r\n            }\r\n        } while (nextComponent && epoch < stopCondition.epoch);\r\n    }\r\n\r\n    _findNextTrajectory(trajectory, epochFrom, epochTo) {\r\n        const soi = sim.starSystem.getObject(trajectory.referenceFrame.originId);\r\n        const ownSoiCrossing   = this._findOwnSoiCrossing  (soi, trajectory, epochFrom);\r\n        const childSoiCrossing = this._findChildSoiCrossing(soi, trajectory, epochFrom, epochTo);\r\n\r\n        if (childSoiCrossing === false && ownSoiCrossing === false) {\r\n            return false;\r\n        }\r\n\r\n        let nextSoiCrossing = (!childSoiCrossing || (ownSoiCrossing && ownSoiCrossing.epoch < childSoiCrossing.epoch))\r\n            ? ownSoiCrossing\r\n            : childSoiCrossing;\r\n\r\n        return this._createExtensionTrajectory(trajectory, nextSoiCrossing.newSoi, nextSoiCrossing.epoch);\r\n    }\r\n\r\n    _findOwnSoiCrossing(parent, trajectory, epochFrom) {\r\n        const ko = trajectory.keplerianObject;\r\n        const sphereCrossing = ko.getSphereCrossingTrueAnomaly(parent.data.patchedConics.soiRadius);\r\n\r\n        if (!sphereCrossing) {\r\n            return false;\r\n        }\r\n\r\n        let epoch = ko.getEpochByTrueAnomaly(sphereCrossing[0]);\r\n        while (epoch < epochFrom) {\r\n            epoch += ko.period;\r\n        }\r\n\r\n        return {\r\n            epoch: epoch,\r\n            newSoi: parent.data.patchedConics.parentSoi\r\n        };\r\n    }\r\n\r\n    _findChildSoiCrossing(parent, trajectory, epochFrom, epochTo) {\r\n        const ko = trajectory.keplerianObject;\r\n        let crossings = [];\r\n\r\n        for (let soi of parent.data.patchedConics.childSois) {\r\n            const childKo = soi.trajectory.getKeplerianObjectByEpoch(epochFrom, trajectory.referenceFrame);\r\n            const soiRadius = soi.data.patchedConics.soiRadius;\r\n            const intervals1 = this._getPotentialApproachIntervals(childKo, ko, epochFrom, epochTo, soiRadius * this.soiSafetyCoefficient);\r\n            if (intervals1 === false) {\r\n                continue;\r\n            }\r\n\r\n            const intervals2 = this._getPotentialApproachIntervals(ko, childKo, epochFrom, epochTo, soiRadius * this.soiSafetyCoefficient);\r\n/*\r\n            if (this.debugPoints.length === 0) {\r\n                if (intervals1 && intervals1 instanceof Array)\r\n                    for (let interval of intervals1) {\r\n                        this.debugPoints.push(new VisualPoint(new Constant(trajectory.getPositionByEpoch(interval[0], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'blue', 6));\r\n                        this.debugPoints.push(new VisualPoint(new Constant(trajectory.getPositionByEpoch(interval[1], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'blue', 10));\r\n                    }\r\n\r\n                if (intervals2 && intervals2 instanceof Array)\r\n                    for (let interval of intervals2) {\r\n                        this.debugPoints.push(new VisualPoint(new Constant(soi.trajectory.getPositionByEpoch(interval[0], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'yellow', 6));\r\n                        this.debugPoints.push(new VisualPoint(new Constant(soi.trajectory.getPositionByEpoch(interval[1], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'yellow', 10));\r\n                    }\r\n            }\r\n*/\r\n            let potentialApproachIntervals = getEpochIntervalsIntersection(intervals1, intervals2);\r\n\r\n            if (potentialApproachIntervals === false) {\r\n                continue;\r\n            }\r\n            if (potentialApproachIntervals === true) {\r\n                // TODO optimize this case\r\n                potentialApproachIntervals = [[epochFrom, epochTo]];\r\n            }\r\n\r\n            potentialApproachIntervals.sort((i1, i2) => (i1[0] < i2[0]) ? -1 : (i1[0] > i2[0] ? 1 : 0));\r\n\r\n            let crossingFound = false;\r\n            // console.log('Iterating...');\r\n            for (let interval of potentialApproachIntervals) {\r\n                if (interval[0] > epochTo) {\r\n                    break;\r\n                }\r\n                if (interval[1] < epochFrom) {\r\n                    continue;\r\n                }\r\n                if (interval[0] < epochFrom) {\r\n                    interval[0] = epochFrom;\r\n                }\r\n                if (interval[1] > epochTo) {\r\n                    interval[1] = epochTo;\r\n                }\r\n                let isFirstStep = true;\r\n                let step = Math.min(this.maxStep, (interval[1] - interval[0]) / this.minStepCount);\r\n                let t = interval[0];\r\n                let prevDistance = 0;\r\n                // console.log('Iterating interval...', interval[1] - interval[0], step);\r\n                while (t < interval[1]) {\r\n                    let distance = trajectory.getPositionByEpoch(t).sub_(soi.getPositionByEpoch(t)).mag - soiRadius;\r\n                    // console.log('T Distance', t, distance);\r\n                    if (distance < 0) { // found a point in time when we are inside SOI\r\n                        // console.log('Found');\r\n                        if (isFirstStep) {\r\n                            // console.log('Iterating forward');\r\n                            do {\r\n                                t += step;\r\n                                if (t > interval[1]) {\r\n                                    t = interval[1];\r\n                                }\r\n                                distance = trajectory.getPositionByEpoch(t).sub_(soi.getPositionByEpoch(t)).mag - soiRadius;\r\n                            } while (distance < 0 && t < interval[1]);\r\n                            // console.log('Distance', distance);\r\n                            if (distance < 0) {\r\n                                break;\r\n                            }\r\n                            continue;\r\n                        }\r\n                        // console.log('Looking for boundary');\r\n                        while (Math.abs(distance) > this.maxPatchError) { // looking for SOI crossing time now\r\n                            step *= distance / (prevDistance - distance);\r\n                            t += step;\r\n                            prevDistance = distance;\r\n                            distance = trajectory.getPositionByEpoch(t).sub_(soi.getPositionByEpoch(t)).mag - soiRadius;\r\n                            // console.log('T Step distance', t, step, distance);\r\n                        }\r\n                        // console.log('Boundary found', t);\r\n                        crossings.push({\r\n                            epoch: t,\r\n                            newSoi: soi\r\n                        });\r\n                        crossingFound = true;\r\n                        break;\r\n                    }\r\n                    prevDistance = distance;\r\n                    isFirstStep = false;\r\n                    t += step;\r\n                }\r\n\r\n                if (crossingFound) {\r\n                    break;\r\n                }\r\n                // console.log('Crossing not found');\r\n            }\r\n        }\r\n\r\n        if (!crossings.length) {\r\n            return false;\r\n        }\r\n\r\n        let closestCrossing = crossings[0];\r\n        for (let crossing of crossings) {\r\n            if (crossing.epoch < closestCrossing.epoch) {\r\n                closestCrossing = crossing;\r\n            }\r\n        }\r\n\r\n        return closestCrossing;\r\n    }\r\n\r\n    _getPotentialApproachIntervals(keplerianObjectBase, keplerianObjectActive, epochFrom, epochTo, distance) {\r\n        const radialTa = this._getRadialTaBounds(keplerianObjectBase, keplerianObjectActive, distance);\r\n        if (radialTa === false) {\r\n            return false;\r\n        }\r\n\r\n        const verticalTa = this._getVerticalTaBounds(keplerianObjectBase, keplerianObjectActive, epochFrom, distance);\r\n        let taIntervals;\r\n\r\n        if (verticalTa) {\r\n            taIntervals = getAngleIntervalsIntersection(verticalTa, radialTa);\r\n        } else {\r\n            if (radialTa === true) {\r\n                return true;\r\n            } else {\r\n                taIntervals = radialTa;\r\n            }\r\n        }\r\n\r\n        if (taIntervals === false) {\r\n            return false;\r\n        }\r\n\r\n        const period = keplerianObjectActive.period;\r\n        let inEpoch, outEpoch;\r\n        let adding = keplerianObjectActive.isElliptic\r\n            ? Math.floor((epochFrom - keplerianObjectActive.epoch) / period) * period\r\n            : 0;\r\n        let maxProcessedEpoch = 0;\r\n        let epochIntervals = [];\r\n\r\n        do {\r\n            for (let taInterval of taIntervals) {\r\n                inEpoch = keplerianObjectActive.getEpochByTrueAnomaly(taInterval[0]) + adding;\r\n                outEpoch = keplerianObjectActive.getEpochByTrueAnomaly(taInterval[1]) + adding;\r\n\r\n                if (outEpoch < inEpoch) {\r\n                    inEpoch -= period;\r\n                }\r\n\r\n                if (outEpoch > maxProcessedEpoch) {\r\n                    maxProcessedEpoch = outEpoch;\r\n                }\r\n                if (outEpoch < epochFrom) {\r\n                    continue;\r\n                }\r\n\r\n                if (epochIntervals.length > 10000) {\r\n                    debugger;\r\n                    throw new Error('Infinite loop detected');\r\n                }\r\n\r\n                epochIntervals.push([inEpoch, outEpoch]);\r\n            }\r\n            adding += period;\r\n\r\n        } while (maxProcessedEpoch < epochTo && keplerianObjectActive.isElliptic);\r\n\r\n        return epochIntervals;\r\n    }\r\n\r\n    _getVerticalTaBounds(keplerianObjectBase, keplerianObjectActive, epochFrom, distance) {\r\n        // this is only to recalculate inc, raan and aop. probably can be optimized.\r\n        const baseNormal = keplerianObjectBase.getNormalVector();\r\n        const activeNormal = keplerianObjectActive.getNormalVector();\r\n        const equinoxVector = keplerianObjectBase.getPeriapsisVector();\r\n        const raanVector = baseNormal.cross(activeNormal);\r\n        const periapsisVector = keplerianObjectActive.getPeriapsisVector();\r\n\r\n        const inc = baseNormal.angle(activeNormal);\r\n        let raan = raanVector.angle(equinoxVector);\r\n        if (equinoxVector.cross(raanVector).angle(baseNormal) > Math.PI / 2) {\r\n            raan = TWO_PI - raan;\r\n        }\r\n        let aop = raanVector.angle(periapsisVector);\r\n        if (raanVector.cross(periapsisVector).angle(activeNormal) > Math.PI / 2) {\r\n            aop = TWO_PI - aop;\r\n        }\r\n\r\n        const relKeplerianObject = new KeplerianObject(\r\n            keplerianObjectActive.ecc,\r\n            keplerianObjectActive.sma,\r\n            aop,\r\n            inc,\r\n            raan,\r\n            keplerianObjectActive.m0,\r\n            keplerianObjectActive.epoch,\r\n            keplerianObjectActive.mu,\r\n            false\r\n        );\r\n\r\n        return relKeplerianObject.getPlaneCrossingTrueAnomaly(distance);\r\n    }\r\n\r\n    _getRadialTaBounds(keplerianObjectBase, keplerianObjectActive, distance) {\r\n        const r1 = keplerianObjectBase.getPeriapsisRadius() - distance;\r\n        const r2 = keplerianObjectBase.getApoapsisRadius()  + distance;\r\n        const radialTa1 = keplerianObjectActive.getSphereCrossingTrueAnomaly(r1);\r\n        const radialTa2 = keplerianObjectActive.getSphereCrossingTrueAnomaly(r2);\r\n\r\n        if (keplerianObjectBase.isHyperbolic) {\r\n            if (keplerianObjectActive.isHyperbolic) {\r\n                return radialTa1\r\n                    ? [[-Infinity, radialTa1[1] - TWO_PI],[radialTa1[0], Infinity]]\r\n                    : true;\r\n            } else {\r\n                return radialTa1\r\n                    ? [radialTa1]\r\n                    : (keplerianObjectActive.getApoapsisRadius() >= r1);\r\n            }\r\n        }\r\n        // keplerianObjectBase is elliptic\r\n\r\n        if (keplerianObjectActive.isHyperbolic) {\r\n            if (!radialTa2) {\r\n                return false;\r\n            } else if (!radialTa1) {\r\n                return [[radialTa2[1] - TWO_PI, radialTa2[0]]];\r\n            }\r\n            return [\r\n                [radialTa2[1] - TWO_PI, radialTa1[1] - TWO_PI],\r\n                [radialTa1[0], radialTa2[0]],\r\n            ];\r\n        }\r\n        // keplerianObjectActive is elliptic\r\n\r\n        if (radialTa1) {\r\n            return radialTa2\r\n                ? [[radialTa1[0], radialTa2[0]], [radialTa2[1], radialTa1[1]]]\r\n                : [radialTa1];\r\n        } else if (radialTa2) {\r\n            return [[radialTa2[1], radialTa2[0]]];\r\n        }\r\n        return keplerianObjectActive.getPeriapsisRadius() < r2\r\n            && keplerianObjectActive.getApoapsisRadius()  > r1;\r\n    }\r\n\r\n    _createExtensionTrajectory(originalTrajectory, newSoiBody, epoch) {\r\n        let newReferenceFrame = sim.starSystem.getReferenceFrame(ReferenceFrameFactory.buildId(newSoiBody.id, ReferenceFrame.INERTIAL_ECLIPTIC));\r\n        let newSoiState = newReferenceFrame.stateVectorFromBaseReferenceFrameByEpoch(\r\n            epoch,\r\n            originalTrajectory.getStateByEpoch(epoch)\r\n        );\r\n\r\n        let traj = new TrajectoryKeplerianBasic(\r\n            newReferenceFrame.id,\r\n            KeplerianObject.createFromState(\r\n                newSoiState,\r\n                newSoiBody.physicalModel.mu,\r\n                epoch\r\n            )\r\n        );\r\n        traj.minEpoch = epoch;\r\n        traj.maxEpoch = false;\r\n        traj.isEditable = false;\r\n\r\n        // TODO refactor this\r\n        traj.setVisualModel(new VisualTrajectoryModelKeplerian(\r\n            traj,\r\n            {color: originalTrajectory.visualModel.standardColor, minEpoch: null, maxEpoch: null}\r\n        ));\r\n\r\n        return traj;\r\n    }\r\n\r\n}\r\n"],"sourceRoot":""}