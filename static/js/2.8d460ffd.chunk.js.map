{"version":3,"sources":["core/Module.js","core/Propagator/Abstract.js","modules/PatchedConics/PropagatorPatchedConics.js","modules/PatchedConics/ModulePatchedConics.js"],"names":["Module","Object","D_Projects_github_com_urbain_ru_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","this","_classes","alias","className","undefined","Error","PropagatorAbstract","trajectory","epochFrom","stopCondition","PropagatorPatchedConics","_this","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","soiSafetyCoefficient","maxStep","minStepCount","maxPatchError","TrajectoryComposite","epoch","clearAfterEpoch","nextComponent","lastComponent","getComponentByEpoch","Math","max","maxEpoch","_findNextTrajectory","addComponent","epochTo","soi","sim","starSystem","getObject","referenceFrame","originId","ownSoiCrossing","_findOwnSoiCrossing","childSoiCrossing","_findChildSoiCrossing","nextSoiCrossing","_createExtensionTrajectory","newSoi","parent","ko","keplerianObject","sphereCrossing","getSphereCrossingTrueAnomaly","data","patchedConics","soiRadius","getEpochByTrueAnomaly","period","parentSoi","crossings","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","childSois","Symbol","iterator","next","done","value","childKo","getKeplerianObjectByEpoch","intervals1","_getPotentialApproachIntervals","intervals2","potentialApproachIntervals","getEpochIntervalsIntersection","sort","i1","i2","crossingFound","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","interval","isFirstStep","step","min","t","prevDistance","distance","getPositionByEpoch","sub_","mag","abs","push","err","return","length","closestCrossing","_i","crossing","keplerianObjectBase","keplerianObjectActive","radialTa","_getRadialTaBounds","taIntervals","verticalTa","_getVerticalTaBounds","getAngleIntervalsIntersection","inEpoch","outEpoch","adding","isElliptic","floor","maxProcessedEpoch","epochIntervals","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","taInterval","baseNormal","getNormalVector","activeNormal","equinoxVector","getPeriapsisVector","raanVector","cross","periapsisVector","inc","angle","raan","PI","TWO_PI","aop","KeplerianObject","ecc","sma","m0","mu","getPlaneCrossingTrueAnomaly","r1","getPeriapsisRadius","r2","getApoapsisRadius","radialTa1","radialTa2","isHyperbolic","Infinity","originalTrajectory","newSoiBody","newReferenceFrame","getReferenceFrame","ReferenceFrameFactory","buildId","id","ReferenceFrame","INERTIAL_ECLIPTIC","newSoiState","stateVectorFromBaseReferenceFrameByEpoch","getStateByEpoch","traj","TrajectoryKeplerianBasic","createFromState","physicalModel","minEpoch","isEditable","setVisualModel","VisualTrajectoryModelKeplerian","color","visualModel","standardColor","ModulePatchedConics","addPropagator","Events","addListener","STAR_SYSTEM_LOADED","fillSoiTree","ss","bodyId","objects","obj","Body","parentSoiId"],"mappings":"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","file":"static/js/2.8d460ffd.chunk.js","sourcesContent":["export default class Module\r\n{\r\n    constructor() {\r\n        this._classes = {};\r\n    }\r\n\r\n    _addClass(alias, className) {\r\n        this._classes[alias] = className;\r\n    }\r\n\r\n    getClass(alias) {\r\n        if (this._classes[alias] === undefined) {\r\n            throw new Error('Unknown module class: ' + alias);\r\n        }\r\n        return this._classes[alias];\r\n    }\r\n\r\n    init() {}\r\n}\r\n","export default class PropagatorAbstract\r\n{\r\n    propagate(trajectory, epochFrom, stopCondition) {}\r\n}","import PropagatorAbstract from \"../../core/Propagator/Abstract\";\r\nimport TrajectoryComposite from \"../../core/Trajectory/Composite\";\r\nimport ReferenceFrameFactory, {ReferenceFrame} from \"../../core/ReferenceFrame/Factory\";\r\nimport TrajectoryKeplerianBasic from \"../../core/Trajectory/KeplerianBasic\";\r\nimport KeplerianObject from \"../../core/KeplerianObject\";\r\nimport VisualTrajectoryModelKeplerian from \"../../core/visual/TrajectoryModel/Keplerian\";\r\nimport {getAngleIntervalsIntersection, getEpochIntervalsIntersection, TWO_PI} from \"../../core/algebra\";\r\nimport { sim } from \"../../core/Simulation\";\r\n// import VisualPoint from \"../../visual/Point\";\r\n// import Constant from \"../../core/FunctionOfEpoch/Constant\";\r\n\r\nexport default class PropagatorPatchedConics extends PropagatorAbstract\r\n{\r\n    constructor() {\r\n        super();\r\n        this.soiSafetyCoefficient = 1.5;\r\n        this.maxStep = 3600;\r\n        this.minStepCount = 100;\r\n        this.maxPatchError = 1e-3; // 1 meter\r\n        // this.debugPoints = [];\r\n    }\r\n\r\n    propagate(trajectory, epochFrom, stopCondition) {\r\n        if (!trajectory instanceof TrajectoryComposite) {\r\n            throw new Error('Patched conics propagation requires TrajectoryComposite instance');\r\n        }\r\n        if (!stopCondition.epoch) {\r\n            throw new Error('Patched conics propagation requires epoch in stop condition');\r\n        }\r\n\r\n        trajectory.clearAfterEpoch(epochFrom);\r\n\r\n        let lastComponent = trajectory.getComponentByEpoch(epochFrom);\r\n        let epoch = Math.max(epochFrom, lastComponent.epoch);\r\n        let nextComponent;\r\n\r\n        lastComponent.maxEpoch = false;\r\n/*\r\n        for (let point of this.debugPoints) {\r\n            point.drop();\r\n        }\r\n        this.debugPoints = [];\r\n*/\r\n        // console.log('Propagating...');\r\n\r\n        do {\r\n            // console.log('Looking for next component...');\r\n            nextComponent = this._findNextTrajectory(lastComponent, epoch, stopCondition.epoch);\r\n            if (nextComponent) {\r\n                // console.log('Component found', nextComponent);\r\n                trajectory.addComponent(nextComponent);\r\n                epoch = nextComponent.epoch;\r\n                lastComponent.maxEpoch = epoch;\r\n                lastComponent = nextComponent;\r\n            }\r\n        } while (nextComponent && epoch < stopCondition.epoch);\r\n    }\r\n\r\n    _findNextTrajectory(trajectory, epochFrom, epochTo) {\r\n        const soi = sim.starSystem.getObject(trajectory.referenceFrame.originId);\r\n        const ownSoiCrossing   = this._findOwnSoiCrossing  (soi, trajectory, epochFrom);\r\n        const childSoiCrossing = this._findChildSoiCrossing(soi, trajectory, epochFrom, epochTo);\r\n\r\n        if (childSoiCrossing === false && ownSoiCrossing === false) {\r\n            return false;\r\n        }\r\n\r\n        let nextSoiCrossing = (!childSoiCrossing || (ownSoiCrossing && ownSoiCrossing.epoch < childSoiCrossing.epoch))\r\n            ? ownSoiCrossing\r\n            : childSoiCrossing;\r\n\r\n        return this._createExtensionTrajectory(trajectory, nextSoiCrossing.newSoi, nextSoiCrossing.epoch);\r\n    }\r\n\r\n    _findOwnSoiCrossing(parent, trajectory, epochFrom) {\r\n        const ko = trajectory.keplerianObject;\r\n        const sphereCrossing = ko.getSphereCrossingTrueAnomaly(parent.data.patchedConics.soiRadius);\r\n\r\n        if (!sphereCrossing) {\r\n            return false;\r\n        }\r\n\r\n        let epoch = ko.getEpochByTrueAnomaly(sphereCrossing[0]);\r\n        while (epoch < epochFrom) {\r\n            epoch += ko.period;\r\n        }\r\n\r\n        return {\r\n            epoch: epoch,\r\n            newSoi: parent.data.patchedConics.parentSoi\r\n        };\r\n    }\r\n\r\n    _findChildSoiCrossing(parent, trajectory, epochFrom, epochTo) {\r\n        const ko = trajectory.keplerianObject;\r\n        let crossings = [];\r\n\r\n        for (let soi of parent.data.patchedConics.childSois) {\r\n            const childKo = soi.trajectory.getKeplerianObjectByEpoch(epochFrom, trajectory.referenceFrame);\r\n            const soiRadius = soi.data.patchedConics.soiRadius;\r\n            const intervals1 = this._getPotentialApproachIntervals(childKo, ko, epochFrom, epochTo, soiRadius * this.soiSafetyCoefficient);\r\n            if (intervals1 === false) {\r\n                continue;\r\n            }\r\n\r\n            const intervals2 = this._getPotentialApproachIntervals(ko, childKo, epochFrom, epochTo, soiRadius * this.soiSafetyCoefficient);\r\n/*\r\n            if (this.debugPoints.length === 0) {\r\n                if (intervals1 && intervals1 instanceof Array)\r\n                    for (let interval of intervals1) {\r\n                        this.debugPoints.push(new VisualPoint(new Constant(trajectory.getPositionByEpoch(interval[0], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'blue', 6));\r\n                        this.debugPoints.push(new VisualPoint(new Constant(trajectory.getPositionByEpoch(interval[1], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'blue', 10));\r\n                    }\r\n\r\n                if (intervals2 && intervals2 instanceof Array)\r\n                    for (let interval of intervals2) {\r\n                        this.debugPoints.push(new VisualPoint(new Constant(soi.trajectory.getPositionByEpoch(interval[0], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'yellow', 6));\r\n                        this.debugPoints.push(new VisualPoint(new Constant(soi.trajectory.getPositionByEpoch(interval[1], 39901000).add_(parent.getPositionByEpoch(sim.currentEpoch))), 'yellow', 10));\r\n                    }\r\n            }\r\n*/\r\n            let potentialApproachIntervals = getEpochIntervalsIntersection(intervals1, intervals2);\r\n\r\n            if (potentialApproachIntervals === false) {\r\n                continue;\r\n            }\r\n            if (potentialApproachIntervals === true) {\r\n                // TODO optimize this case\r\n                potentialApproachIntervals = [[epochFrom, epochTo]];\r\n            }\r\n\r\n            potentialApproachIntervals.sort((i1, i2) => (i1[0] < i2[0]) ? -1 : (i1[0] > i2[0] ? 1 : 0));\r\n\r\n            let crossingFound = false;\r\n            // console.log('Iterating...');\r\n            for (let interval of potentialApproachIntervals) {\r\n                if (interval[0] > epochTo) {\r\n                    break;\r\n                }\r\n                if (interval[1] < epochFrom) {\r\n                    continue;\r\n                }\r\n                if (interval[0] < epochFrom) {\r\n                    interval[0] = epochFrom;\r\n                }\r\n                if (interval[1] > epochTo) {\r\n                    interval[1] = epochTo;\r\n                }\r\n                let isFirstStep = true;\r\n                let step = Math.min(this.maxStep, (interval[1] - interval[0]) / this.minStepCount);\r\n                let t = interval[0];\r\n                let prevDistance = 0;\r\n                // console.log('Iterating interval...', interval[1] - interval[0], step);\r\n                while (t < interval[1]) {\r\n                    let distance = trajectory.getPositionByEpoch(t).sub_(soi.getPositionByEpoch(t)).mag - soiRadius;\r\n                    // console.log('T Distance', t, distance);\r\n                    if (distance < 0) { // found a point in time when we are inside SOI\r\n                        // console.log('Found');\r\n                        if (isFirstStep) {\r\n                            // console.log('Iterating forward');\r\n                            do {\r\n                                t += step;\r\n                                if (t > interval[1]) {\r\n                                    t = interval[1];\r\n                                }\r\n                                distance = trajectory.getPositionByEpoch(t).sub_(soi.getPositionByEpoch(t)).mag - soiRadius;\r\n                            } while (distance < 0 && t < interval[1]);\r\n                            // console.log('Distance', distance);\r\n                            if (distance < 0) {\r\n                                break;\r\n                            }\r\n                            continue;\r\n                        }\r\n                        // console.log('Looking for boundary');\r\n                        while (Math.abs(distance) > this.maxPatchError) { // looking for SOI crossing time now\r\n                            step *= distance / (prevDistance - distance);\r\n                            t += step;\r\n                            prevDistance = distance;\r\n                            distance = trajectory.getPositionByEpoch(t).sub_(soi.getPositionByEpoch(t)).mag - soiRadius;\r\n                            // console.log('T Step distance', t, step, distance);\r\n                        }\r\n                        // console.log('Boundary found', t);\r\n                        crossings.push({\r\n                            epoch: t,\r\n                            newSoi: soi\r\n                        });\r\n                        crossingFound = true;\r\n                        break;\r\n                    }\r\n                    prevDistance = distance;\r\n                    isFirstStep = false;\r\n                    t += step;\r\n                }\r\n\r\n                if (crossingFound) {\r\n                    break;\r\n                }\r\n                // console.log('Crossing not found');\r\n            }\r\n        }\r\n\r\n        if (!crossings.length) {\r\n            return false;\r\n        }\r\n\r\n        let closestCrossing = crossings[0];\r\n        for (let crossing of crossings) {\r\n            if (crossing.epoch < closestCrossing.epoch) {\r\n                closestCrossing = crossing;\r\n            }\r\n        }\r\n\r\n        return closestCrossing;\r\n    }\r\n\r\n    _getPotentialApproachIntervals(keplerianObjectBase, keplerianObjectActive, epochFrom, epochTo, distance) {\r\n        const radialTa = this._getRadialTaBounds(keplerianObjectBase, keplerianObjectActive, distance);\r\n        if (radialTa === false) {\r\n            return false;\r\n        }\r\n\r\n        const verticalTa = this._getVerticalTaBounds(keplerianObjectBase, keplerianObjectActive, epochFrom, distance);\r\n        let taIntervals;\r\n\r\n        if (verticalTa) {\r\n            taIntervals = getAngleIntervalsIntersection(verticalTa, radialTa);\r\n        } else {\r\n            if (radialTa === true) {\r\n                return true;\r\n            } else {\r\n                taIntervals = radialTa;\r\n            }\r\n        }\r\n\r\n        if (taIntervals === false) {\r\n            return false;\r\n        }\r\n\r\n        const period = keplerianObjectActive.period;\r\n        let inEpoch, outEpoch;\r\n        let adding = keplerianObjectActive.isElliptic\r\n            ? Math.floor((epochFrom - keplerianObjectActive.epoch) / period) * period\r\n            : 0;\r\n        let maxProcessedEpoch = 0;\r\n        let epochIntervals = [];\r\n\r\n        do {\r\n            for (let taInterval of taIntervals) {\r\n                inEpoch = keplerianObjectActive.getEpochByTrueAnomaly(taInterval[0]) + adding;\r\n                outEpoch = keplerianObjectActive.getEpochByTrueAnomaly(taInterval[1]) + adding;\r\n\r\n                if (outEpoch < inEpoch) {\r\n                    inEpoch -= period;\r\n                }\r\n\r\n                if (outEpoch > maxProcessedEpoch) {\r\n                    maxProcessedEpoch = outEpoch;\r\n                }\r\n                if (outEpoch < epochFrom) {\r\n                    continue;\r\n                }\r\n\r\n                if (epochIntervals.length > 10000) {\r\n                    debugger;\r\n                    throw new Error('Infinite loop detected');\r\n                }\r\n\r\n                epochIntervals.push([inEpoch, outEpoch]);\r\n            }\r\n            adding += period;\r\n\r\n        } while (maxProcessedEpoch < epochTo && keplerianObjectActive.isElliptic);\r\n\r\n        return epochIntervals;\r\n    }\r\n\r\n    _getVerticalTaBounds(keplerianObjectBase, keplerianObjectActive, epochFrom, distance) {\r\n        // this is only to recalculate inc, raan and aop. probably can be optimized.\r\n        const baseNormal = keplerianObjectBase.getNormalVector();\r\n        const activeNormal = keplerianObjectActive.getNormalVector();\r\n        const equinoxVector = keplerianObjectBase.getPeriapsisVector();\r\n        const raanVector = baseNormal.cross(activeNormal);\r\n        const periapsisVector = keplerianObjectActive.getPeriapsisVector();\r\n\r\n        const inc = baseNormal.angle(activeNormal);\r\n        let raan = raanVector.angle(equinoxVector);\r\n        if (equinoxVector.cross(raanVector).angle(baseNormal) > Math.PI / 2) {\r\n            raan = TWO_PI - raan;\r\n        }\r\n        let aop = raanVector.angle(periapsisVector);\r\n        if (raanVector.cross(periapsisVector).angle(activeNormal) > Math.PI / 2) {\r\n            aop = TWO_PI - aop;\r\n        }\r\n\r\n        const relKeplerianObject = new KeplerianObject(\r\n            keplerianObjectActive.ecc,\r\n            keplerianObjectActive.sma,\r\n            aop,\r\n            inc,\r\n            raan,\r\n            keplerianObjectActive.m0,\r\n            keplerianObjectActive.epoch,\r\n            keplerianObjectActive.mu,\r\n            false\r\n        );\r\n\r\n        return relKeplerianObject.getPlaneCrossingTrueAnomaly(distance);\r\n    }\r\n\r\n    _getRadialTaBounds(keplerianObjectBase, keplerianObjectActive, distance) {\r\n        const r1 = keplerianObjectBase.getPeriapsisRadius() - distance;\r\n        const r2 = keplerianObjectBase.getApoapsisRadius()  + distance;\r\n        const radialTa1 = keplerianObjectActive.getSphereCrossingTrueAnomaly(r1);\r\n        const radialTa2 = keplerianObjectActive.getSphereCrossingTrueAnomaly(r2);\r\n\r\n        if (keplerianObjectBase.isHyperbolic) {\r\n            if (keplerianObjectActive.isHyperbolic) {\r\n                return radialTa1\r\n                    ? [[-Infinity, radialTa1[1] - TWO_PI],[radialTa1[0], Infinity]]\r\n                    : true;\r\n            } else {\r\n                return radialTa1\r\n                    ? [radialTa1]\r\n                    : (keplerianObjectActive.getApoapsisRadius() >= r1);\r\n            }\r\n        }\r\n        // keplerianObjectBase is elliptic\r\n\r\n        if (keplerianObjectActive.isHyperbolic) {\r\n            if (!radialTa2) {\r\n                return false;\r\n            } else if (!radialTa1) {\r\n                return [[radialTa2[1] - TWO_PI, radialTa2[0]]];\r\n            }\r\n            return [\r\n                [radialTa2[1] - TWO_PI, radialTa1[1] - TWO_PI],\r\n                [radialTa1[0], radialTa2[0]],\r\n            ];\r\n        }\r\n        // keplerianObjectActive is elliptic\r\n\r\n        if (radialTa1) {\r\n            return radialTa2\r\n                ? [[radialTa1[0], radialTa2[0]], [radialTa2[1], radialTa1[1]]]\r\n                : [radialTa1];\r\n        } else if (radialTa2) {\r\n            return [[radialTa2[1], radialTa2[0]]];\r\n        }\r\n        return keplerianObjectActive.getPeriapsisRadius() < r2\r\n            && keplerianObjectActive.getApoapsisRadius()  > r1;\r\n    }\r\n\r\n    _createExtensionTrajectory(originalTrajectory, newSoiBody, epoch) {\r\n        let newReferenceFrame = sim.starSystem.getReferenceFrame(ReferenceFrameFactory.buildId(newSoiBody.id, ReferenceFrame.INERTIAL_ECLIPTIC));\r\n        let newSoiState = newReferenceFrame.stateVectorFromBaseReferenceFrameByEpoch(\r\n            epoch,\r\n            originalTrajectory.getStateByEpoch(epoch)\r\n        );\r\n\r\n        let traj = new TrajectoryKeplerianBasic(\r\n            newReferenceFrame.id,\r\n            KeplerianObject.createFromState(\r\n                newSoiState,\r\n                newSoiBody.physicalModel.mu,\r\n                epoch\r\n            )\r\n        );\r\n        traj.minEpoch = epoch;\r\n        traj.maxEpoch = false;\r\n        traj.isEditable = false;\r\n\r\n        // TODO refactor this\r\n        traj.setVisualModel(new VisualTrajectoryModelKeplerian(\r\n            traj,\r\n            {color: originalTrajectory.visualModel.standardColor, minEpoch: null, maxEpoch: null}\r\n        ));\r\n\r\n        return traj;\r\n    }\r\n\r\n}\r\n","import Module from \"../../core/Module\";\r\nimport Events from \"../../core/Events\";\r\nimport Body from \"../../core/Body\";\r\nimport PropagatorPatchedConics from \"./PropagatorPatchedConics\";\r\nimport { sim } from \"../../core/Simulation\";\r\n\r\nexport default class ModulePatchedConics extends Module\r\n{\r\n    init() {\r\n        sim.addPropagator('patchedConics', PropagatorPatchedConics);\r\n        Events.addListener(Events.STAR_SYSTEM_LOADED, this.fillSoiTree);\r\n        if (sim.starSystem) {\r\n            this.fillSoiTree();\r\n        }\r\n    }\r\n\r\n    fillSoiTree() {\r\n        let ss = sim.starSystem;\r\n\r\n        for (let bodyId in ss.objects) {\r\n            let obj = ss.objects[bodyId];\r\n            if (!(obj instanceof Body) || obj.data.patchedConics === undefined)\r\n                continue;\r\n\r\n            let parent = ss.getObject(obj.data.patchedConics.parentSoiId);\r\n\r\n            if (!(parent instanceof Body))\r\n                continue;\r\n\r\n            obj.data.patchedConics.parentSoi = parent;\r\n            parent.data.patchedConics.childSois.push(obj);\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""}